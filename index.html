<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arrow Tune Calculator</title>
  <meta name="description" content="Offline arrow tuning calculator – FOC, velocity, impact KE, composition, and more." />
  <link href="https://rsms.me/inter/inter.css" rel="stylesheet">
<style>
  :root {
    --bg:#f8fafc;
    --card:#ffffff;
    --text:#1e293b;
    --light:#64748b;
    --border:#e2e8f0;
    --primary:#0ea5e9;
    --success:#22c55e;
    --warning:#f59e0b;
    --danger:#ef4444;

    /* extra surfaces for tiles */
    --surface-muted:#f1f5f9;
    --surface-strong-shadow:rgba(15,23,42,0.22);
    --tile-shadow:rgba(15,23,42,0.16);
  }
  .dark {
    --bg:#0f172a;
    --card:#020617;
    --text:#e2e8f0;
    --light:#94a3b8;
    --border:#1e293b;
    --surface-muted:#020617;
    --surface-strong-shadow:rgba(0,0,0,0.6);
    --tile-shadow:rgba(0,0,0,0.5);
  }

  * {
    margin:0;
    padding:0;
    box-sizing:border-box;
  }

  body {
    font-family:'Inter',sans-serif;
    background:var(--bg);
    color:var(--text);
    padding:1rem;
    min-height:100vh;
    line-height:1.6;
  }

  .container {
    max-width:1400px;
    margin:auto;
    display:grid;
    gap:1.5rem;
  }
  @media (min-width:1024px) {
    .container { grid-template-columns:1fr 1fr; }
  }

  /* Top-level cards (big sections) */
  .card {
    background:var(--card);
    border:1px solid var(--border);
    border-radius:14px;
    padding:1.5rem;
    box-shadow:0 18px 45px var(--surface-strong-shadow);
    position:relative;
  }

  /* Slight spacing between stacked cards in each column */
  #inputs-column > .card + .card,
  #outputs-column > .card + .card,
  .outputs-column > .card + .card {
    margin-top:1rem;
  }

  /* Inner subcards (like the game panel inside Performance) */
  .subcard {
    background:var(--surface-muted);
    border:1px solid rgba(148,163,184,0.35);
    border-radius:12px;
    box-shadow:0 10px 28px var(--tile-shadow);
    padding:1rem;
  }

  .card-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    border-bottom:1px solid var(--border);
    padding-bottom:0.75rem;
    margin-bottom:0.9rem;
    font-size:1.2rem;
    font-weight:600;
  }
  .card-header.compact {
    padding-bottom:0.5rem;
    margin-bottom:0.5rem;
    border-bottom:none;
  }

  .card-subtitle {
    font-size:0.9rem;
    color:var(--light);
    margin-bottom:0.9rem;
  }

  h1,h2,h3,h4 { color:var(--text); }

  label {
    display:block;
    margin:1rem 0 0.4rem;
    font-weight:600;
    font-size:0.95rem;
  }

  input, select, textarea {
    width:100%;
    padding:0.75rem;
    border:1px solid var(--border);
    border-radius:8px;
    background:var(--card);
    color:var(--text);
    font-size:1rem;
  }
  input:focus, select:focus, textarea:focus {
    outline:none;
    border-color:var(--primary);
    box-shadow:0 0 0 3px rgba(14,165,233,0.25);
  }

  button {
    padding:0.75rem 1.2rem;
    border:none;
    border-radius:999px;
    background:var(--primary);
    color:white;
    font-weight:600;
    cursor:pointer;
    font-size:0.95rem;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:0.25rem;
  }
  button:hover {
    filter:brightness(1.05);
  }

  .btn-small {
    padding:0.45rem 0.9rem;
    font-size:0.85rem;
    border-radius:999px;
  }

  .secondary-btn {
    background:transparent;
    color:var(--primary);
    border:1px solid rgba(14,165,233,0.5);
  }
  .secondary-btn.small {
    padding:0.3rem 0.7rem;
    font-size:0.8rem;
  }

  .btn-refresh { background:var(--warning); }

  .flex {
    display:flex;
    gap:1rem;
    align-items:center;
  }

  .grid-2 {
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:1rem;
  }

  /* Metric grid: 2 columns of tiles */
  .metric-grid {
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:1rem;
    margin-top:0.5rem;
  }

  /* Tile = little card inside a card */
  .metric-tile {
    display:flex;
    flex-direction:column;
    height:100%;
    padding:0.9rem 1rem;
    border-radius:12px;
    background:var(--surface-muted);
    border:1px solid rgba(148,163,184,0.4);
    box-shadow:0 10px 26px var(--tile-shadow);
  }

  .metric-header-row {
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:0.35rem;
  }

  .metric-title {
    display:flex;
    align-items:center;
    gap:0.35rem;
    font-size:0.9rem;
    font-weight:600;
    color:var(--light);
  }

  .metric-main-value {
    display:flex;
    align-items:flex-end;
    gap:0.3rem;
    justify-content:flex-start;
    margin:0.25rem 0 0.15rem;
  }

  .metric-main-value span,
  .metric-main-value input {
    margin:0 !important;
  }

  .metric-value,
  .metric-main-value span:first-child {
    font-size:2.1rem;
    line-height:1.05;
    font-weight:700;
  }

  .metric-unit {
    font-size:0.9rem;
    color:var(--light);
    font-weight:500;
    margin-bottom:0.2rem;
  }

  .metric-note {
    margin-top:0.25rem;
    font-size:0.8rem;
    color:var(--light);
  }

  /* Make AWC tile span both metric-grid columns */
  .metric-grid .awc-wide {
    grid-column: span 2;
  }

  .text-center { text-align:center; }

  .toggle-switch {
    position:relative;
    display:inline-block;
    width:56px;
    height:30px;
  }
  .toggle-switch input { opacity:0; width:0; height:0; }
  .slider {
    position:absolute;
    cursor:pointer;
    inset:0;
    background:#cbd5e1;
    border-radius:34px;
    transition:.3s;
  }
  .slider:before {
    position:absolute;
    content:"";
    height:24px;
    width:24px;
    left:3px;
    bottom:3px;
    background:white;
    border-radius:50%;
    transition:.3s;
  }
  input:checked + .slider { background:var(--primary); }
  input:checked + .slider:before { transform:translateX(26px); }

  .info-btn {
    font-size:1.0rem;
    color:var(--primary);
    background:none;
    border:none;
    cursor:pointer;
    padding:0;
  }
  .info-btn.small {
    font-size:0.85rem;
  }
  .info-btn:hover {
    transform:scale(1.1);
  }

  .math-btn {
    font-size:0.85rem;
    color:var(--primary);
    background:none;
    border:none;
    cursor:pointer;
    opacity:0.9;
    padding:0;
  }
  .math-btn:hover {
    opacity:1;
    transform:scale(1.1);
  }

  .advanced {
    display:none;
    margin-top:1rem;
    padding-top:1rem;
    border-top:1px solid var(--border);
  }

  table {
    width:100%;
    border-collapse:collapse;
    margin-top:0.5rem;
    font-size:0.95rem;
  }
  th, td {
    padding:0.6rem;
    text-align:left;
    border-bottom:1px solid var(--border);
  }
  th {
    background:var(--bg);
    font-weight:600;
  }

  .data-table {
    margin-top:0.3rem;
  }

  /* Build Summary table spacing */
  #summaryTable {
    margin-top:0.25rem;
    font-size:1rem;
  }
  #summaryTable table {
    width:100%;
    border-collapse:separate;
    border-spacing:0 0.4rem;
  }
  #summaryTable td {
    border-bottom:none;
    padding:0.25rem 0;
  }
  #summaryTable td:first-child {
    padding-right:1.8rem;
    font-weight:600;
  }
  #summaryTable td:last-child {
    text-align:right;
  }

  .build-summary {
    margin-top:0.5rem;
  }

  .build-summary button {
    margin-top:0.75rem;
  }

  .patreon-btn,
  .patreon-link {
    display:block;
    margin:2.25rem auto 0;
    background:#ff424d;
    color:white;
    text-decoration:none;
    padding:0.9rem 2rem;
    border-radius:999px;
    font-weight:bold;
    text-align:center;
    max-width:320px;
    box-shadow:0 18px 40px rgba(248,113,113,0.5);
  }

  .light-only { display:block; }
  .dark-only { display:none; }
  .dark .light-only { display:none; }
  .dark .dark-only { display:block; }

  /* Make the whole right column look consistent */
  .outputs-column {
    display:flex;
    flex-direction:column;
    gap:1rem;
  }

  #outputs-column,
  #outputs-column * {
    font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif !important;
    letter-spacing:-0.02em;
  }
  #outputs-column h3 {
    font-size:1.05rem !important;
    margin:0 0 0.4rem 0;
    font-weight:700 !important;
  }

  #smallGameStatus,
  #deerStatus,
  #elkStatus,
  #mooseStatus {
    font-size:2rem !important;
    font-weight:800 !important;
  }

  #outputs-column small {
    font-weight:500 !important;
    font-size:0.9rem;
    opacity:0.85;
  }

  #toast {
    position:fixed;
    bottom:1.5rem;
    right:1.5rem;
    background:var(--card);
    color:var(--text);
    border:1px solid var(--border);
    padding:0.6rem 1.1rem;
    border-radius:999px;
    box-shadow:0 6px 18px rgba(15,23,42,0.25);
    font-size:0.9rem;
    opacity:0;
    pointer-events:none;
    transition:opacity 0.25s ease-out;
    z-index:999;
  }

  /* FOC bar */
  .foc-scale {
    display:flex;
    align-items:center;
    gap:0.5rem;
    margin-top:0.35rem;
    font-size:0.8rem;
    color:var(--light);
  }
  .foc-bar {
    position:relative;
    flex:1;
    height:10px;
    border-radius:999px;
    background:var(--bg);
    overflow:hidden;
  }
  .foc-ideal {
    position:absolute;
    left:40%;
    width:20%;
    top:1px;
    bottom:1px;
    border-radius:999px;
    background:var(--success);
    opacity:0.25;
  }
  .foc-marker {
    position:absolute;
    top:-4px;
    width:0;
    height:18px;
    border-left:2px solid var(--primary);
  }

  /* Composition bar */
  .composition-bar {
    position:relative;
    height:10px;
    border-radius:999px;
    background:var(--bg);
    overflow:hidden;
    display:flex;
    margin-top:0.4rem;
  }
  .comp-segment {
    height:100%;
  }
  .comp-segment.shaft { background:#94a3b8; }
  .comp-segment.point { background:#0ea5e9; }
  .comp-segment.comps { background:#22c55e; }

  /* Performance controls (distance slider + wind) */
  .performance-controls {
    display:flex;
    flex-direction:column;
    gap:0.4rem;
  }
  .field-label {
    font-size:0.85rem;
    font-weight:600;
    color:var(--light);
  }
  .field-row {
    display:flex;
    flex-direction:column;
    gap:0.35rem;
  }
  .number-input.small {
    max-width:140px;
  }
  .distance-ticks {
    display:flex;
    justify-content:space-between;
    font-size:0.7rem;
    color:var(--light);
    margin-top:0.15rem;
  }

  .drop-table {
    margin-top:0.9rem;
  }

  /* Overlay panels */
  .info-overlay {
    position:fixed;
    inset:0;
    background:rgba(15,23,42,0.55);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:998;
  }
  .info-overlay.open {
    display:flex;
  }
  .info-panel {
    background:var(--card);
    color:var(--text);
    border-radius:12px;
    max-width:420px;
    width:90%;
    max-height:80vh;
    padding:1.25rem 1.5rem;
    box-shadow:0 20px 40px rgba(15,23,42,0.35);
    position:relative;
    overflow-y:auto;
  }
  .info-panel h2 {
    margin:0 0 0.5rem 0;
    font-size:1.2rem;
  }
  .info-panel p {
    font-size:0.95rem;
    margin:0.35rem 0;
    color:var(--light);
  }
  .info-close {
    position:absolute;
    top:0.6rem;
    right:0.75rem;
    border:none;
    background:transparent;
    font-size:1.4rem;
    cursor:pointer;
    color:var(--light);
  }
  .info-close:hover {
    color:var(--primary);
  }

  @media (max-width:768px) {
    body {
      padding:0.75rem;
    }
    .container {
      gap:1rem;
      grid-template-columns:1fr;
    }
    .card {
      padding:1.25rem;
    }
    .grid-2 {
      grid-template-columns:1fr;
    }
    .flex {
      flex-wrap:wrap;
    }
    .metric-grid {
      grid-template-columns:1fr;
    }
  }

  /* Performance control strip: FPS / Wind / Distance */
    .perf-grid {
      display: grid;
      grid-template-rows: auto auto;
      gap: 0.75rem;
    }

    .perf-top {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    .perf-box {
      background: var(--surface-muted);
      border: 1px solid rgba(148,163,184,0.45);
      border-radius: 12px;
      padding: 0.85rem 1rem;
      box-shadow: 0 10px 24px var(--tile-shadow);
    }

    .perf-label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.35rem;
    }

    .perf-label-actions {
      display: flex;
      align-items: center;
      gap: 0.35rem;  /* space between ⓘ, ∑, editable */
    }

    .perf-slider-left {
      display: flex;
      align-items: center;
      gap: 0.35rem;  /* space between "Distance", ⓘ, ∑ */
    }

    .perf-label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--light);
    }

    .perf-edit-pill {
      font-size: 0.7rem;
      padding: 0.15rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      color: var(--light);
      background: rgba(15,23,42,0.02);
    }

    .perf-input-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .perf-input-row input {
      max-width: 120px;
      border-radius: 999px;
      padding: 0.55rem 0.9rem;
      font-weight: 600;
    }

    .perf-unit {
      font-size: 0.85rem;
      color: var(--light);
    }

    .perf-hint {
      font-size: 0.75rem;
      color: var(--light);
      margin-top: 0.3rem;
    }

    /* Slider row under both */
    .perf-slider-box {
      background: var(--surface-muted);
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 0.85rem 1rem 1rem;
      box-shadow: 0 10px 24px var(--tile-shadow);
    }

    .perf-slider-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.35rem;
    }

    .perf-slider-label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--light);
    }

    .perf-distance-value {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--primary);
    }

    .perf-slider-box input[type="range"] {
      width: 100%;
    }

    /* keep your existing distance-ticks styling if you have it */
</style>
</head>
<body>
  <div class="container">
    <!-- LEFT: INPUTS -->
    <div id="inputs-column">
      <!-- Title / Theme card -->
      <div class="card">
        <div class="card-header">
          <h1>Arrow Tune Calculator</h1>
          <div class="flex">
            <span style="color:var(--light);">Light</span>
            <label class="toggle-switch">
              <input type="checkbox" id="darkModeToggle"><span class="slider"></span>
            </label>
            <span style="color:var(--light);">Dark</span>
          </div>
        </div>
        <p style="color:var(--light);">
          Offline • Mobile-friendly • Live calculations<br>
          <span style="font-size:0.9rem; color:var(--primary); font-weight:600;">Version 2.0.15</span>
        </p>
      </div>

      <!-- Your Setups -->
      <div class="card">
        <div class="card-header">
          <h2>Your Setups</h2>
        </div>
        <label>
          Build Name
          <button class="info-btn" type="button" data-info="buildName">ⓘ</button>
        </label>
        <div class="flex">
          <input type="text" id="buildName" placeholder="e.g. 2025 Hoyt RX-9 70lb 500gr">
          <button class="btn-small" id="suggestName">Suggest</button>
        </div>
        <div class="flex" style="margin-top:1rem;gap:0.5rem;flex-wrap:wrap;">
          <button id="saveBuild">Save Build</button>
          <select id="loadBuildSelect"><option value="">– Load Build –</option></select>
          <button style="background:var(--danger);" id="deleteBuild">Delete</button>
        </div>
      </div>

      <!-- Bow Setup -->
      <div class="card">
        <div class="card-header">
          <h3>Bow Setup</h3>
          <button class="info-btn" type="button" data-info="bowModel">ⓘ</button>
        </div>
        <div class="grid-2">
          <div>
            <label>
              Bow Model
              <button class="info-btn" type="button" data-info="bowModel">ⓘ</button>
            </label>
            <input type="text" id="bowModel">
          </div>
          <div>
            <label>
              IBO/ATA Speed (FPS)
              <button class="info-btn" type="button" data-info="iboRating">ⓘ</button>
            </label>
            <input type="number" id="iboRating" value="0" step="0.5">
          </div>
          <div>
            <label>
              Draw Weight (lbs)
              <button class="info-btn" type="button" data-info="drawWeight">ⓘ</button>
            </label>
            <input type="number" id="drawWeight" value="70" step="0.5">
          </div>
          <div>
            <label>
              Draw Length (in)
              <button class="info-btn" type="button" data-info="drawLength">ⓘ</button>
            </label>
            <input type="number" id="drawLength" value="30" step="0.5">
          </div>
          <div>
            <label>
              String Add-ons (gr)
              <button class="info-btn" type="button" data-info="stringWeightSimple">ⓘ</button>
            </label>
            <input type="number" id="stringWeightSimple" value="0" step="0.5">
          </div>
          <div>
            <label>
              Application
              <button class="info-btn" type="button" data-info="application">ⓘ</button>
            </label>
            <select id="application">
              <option>Target / 3D</option>
              <option selected>Hunting</option>
              <option>Other</option>
            </select>
          </div>
        </div>

        <div class="flex" style="margin-top:1rem;justify-content:space-between;">
          <label>
            Advanced String Components
            <button class="info-btn" type="button" data-info="toggleString">ⓘ</button>
          </label>
          <label class="toggle-switch">
            <input type="checkbox" id="toggleString"><span class="slider"></span>
          </label>
        </div>
        <div id="stringAdvanced" class="advanced">
          <div class="grid-2">
            <div>
              <label>
                Peep
                <button class="info-btn" type="button" data-info="peepWeight">ⓘ</button>
              </label>
              <input type="number" id="peepWeight" value="0" step="0.5">
            </div>
            <div>
              <label>
                D-Loop
                <button class="info-btn" type="button" data-info="dloopWeight">ⓘ</button>
              </label>
              <input type="number" id="dloopWeight" value="0" step="0.5">
            </div>
            <div>
              <label>
                Kisser
                <button class="info-btn" type="button" data-info="kisserWeight">ⓘ</button>
              </label>
              <input type="number" id="kisserWeight" value="0" step="0.5">
            </div>
            <div>
              <label>
                Silencers
                <button class="info-btn" type="button" data-info="silencersWeight">ⓘ</button>
              </label>
              <input type="number" id="silencersWeight" value="0" step="0.5">
            </div>
          </div>
          <p style="text-align:right;font-weight:600;">
            Total: <span id="stringTotal">0</span> grains
          </p>
        </div>
      </div>

      <!-- Arrow Setup -->
      <div class="card">
        <div class="card-header">
          <h3>Arrow Setup</h3>
          <button class="info-btn" type="button" data-info="arrowName">ⓘ</button>
        </div>

        <!-- Arrow name + spine aligned -->
        <div class="grid-2">
          <div>
            <label>
              Arrow Name
              <button class="info-btn" type="button" data-info="arrowName">ⓘ</button>
            </label>
            <input type="text" id="arrowName">
          </div>
          <div>
            <label>
              Arrow Spine Stiffness
              <button class="info-btn" type="button" data-info="arrowSpine">ⓘ</button>
            </label>
            <input type="number" id="arrowSpine" value="340" step="10">
          </div>
        </div>

        <div class="grid-2">
          <div>
            <label>
              Arrow Length (in)
              <button class="info-btn" type="button" data-info="arrowLength">ⓘ</button>
            </label>
            <input type="number" id="arrowLength" value="28.5" step="0.5">
          </div>
          <div>
            <label>
              Total Arrow Weight (gr)
              <button class="info-btn" type="button" data-info="totalArrowWeightSimple">ⓘ</button>
            </label>
            <input type="number" id="totalArrowWeightSimple" value="450" step="0.5">
            <small id="totalWeightHint"
                   style="display:block;margin-top:0.25rem;font-size:0.85rem;color:var(--light);">
            </small>
          </div>
          <div>
            <label>
              Point Weight (gr)
              <button class="info-btn" type="button" data-info="pointWeight">ⓘ</button>
            </label>
            <input type="number" id="pointWeight" value="150" step="0.5">
          </div>
          <div>
            <label>
              Balance Point (in)
              <button class="info-btn" type="button" data-info="balancePoint">ⓘ</button>
            </label>
            <input type="number" id="balancePoint" value="18.5" step="0.05">
          </div>
        </div>

        <div class="flex" style="margin-top:1rem;justify-content:space-between;">
          <label>
            Advanced Arrow Components
            <button class="info-btn" type="button" data-info="toggleArrow">ⓘ</button>
          </label>
          <label class="toggle-switch">
            <input type="checkbox" id="toggleArrow"><span class="slider"></span>
          </label>
        </div>
        <div id="arrowAdvanced" class="advanced">
          <div class="grid-2">
            <div>
              <label>
                Bare Shaft
                <button class="info-btn" type="button" data-info="bareShaft">ⓘ</button>
              </label>
              <input type="number" id="bareShaft" value="0" step="0.1">
            </div>
            <div>
              <label>
                Nock System
                <button class="info-btn" type="button" data-info="nockWeight">ⓘ</button>
              </label>
              <input type="number" id="nockWeight" value="0" step="0.1">
            </div>
            <div>
              <label>
                Wrap
                <button class="info-btn" type="button" data-info="wrapWeight">ⓘ</button>
              </label>
              <input type="number" id="wrapWeight" value="0" step="0.1">
            </div>
            <div>
              <label>
                Vane Weight (each)
                <button class="info-btn" type="button" data-info="vaneWeightEach">ⓘ</button>
              </label>
              <input type="number" id="vaneWeightEach" value="0" step="0.1">
            </div>
            <div>
              <label>
                Vane Count
                <button class="info-btn" type="button" data-info="vaneCount">ⓘ</button>
              </label>
              <input type="number" id="vaneCount" value="0" step="1">
            </div>
            <div>
              <label>
                Insert/Outsert
                <button class="info-btn" type="button" data-info="insertWeight">ⓘ</button>
              </label>
              <input type="number" id="insertWeight" value="50" step="0.5">
            </div>
            <div>
              <label>
                Glue / Pin Nock
                <button class="info-btn" type="button" data-info="glueWeight">ⓘ</button>
              </label>
              <input type="number" id="glueWeight" value="0" step="0.5">
            </div>
          </div>
          <p style="text-align:right;font-weight:600;">
            Total: <span id="arrowTotal">0.0</span> grains
          </p>
        </div>
      </div>

      <!-- Notes -->
      <div class="card">
        <div class="card-header">
          <h3>Notes</h3>
          <button class="info-btn" type="button" data-info="notes">ⓘ</button>
        </div>
        <textarea id="notes" rows="4" placeholder="Tuning notes..."></textarea>
      </div>
    </div>

       <!-- RIGHT: OUTPUTS & ANALYSIS -->
      <div id="outputs-column">

        <!-- YOUR SETTINGS: Actual FPS + Crosswind + Distance -->
        <section class="card">
          <div class="card-header">
            <h2>Your Settings</h2>
            <button class="info-btn" type="button" data-info="velocitySection">ⓘ</button>
          </div>
          <p class="card-subtitle" style="font-size:0.9rem;color:var(--light);margin-bottom:0.75rem;">
            Adjust these values to drive the calculations to optimize your next shot.
          </p>

          <!-- FPS + Windage + Distance controls -->
          <div class="perf-grid">
            <!-- Row 1: FPS + Windage -->
            <div class="perf-top">
              <!-- FPS editable box -->
              <div class="perf-box">
                <div class="perf-label-row">
                  <div class="metric-title">
                    <span class="perf-label">Launch FPS</span>
                    <button class="info-btn small" type="button" data-info="actualFPS">ⓘ</button>
                    <button class="math-btn" type="button" data-math="fps">∑</button>
                  </div>
                  <!-- <span class="perf-edit-pill">editable</span> -->
                </div>
                <div class="perf-input-row">
                  <input
                    id="actualFPS"
                    type="number"
                    inputmode="decimal"
                    step="0.5"
                    min="100"
                    max="400"
                    placeholder="Estimate or chrono"
                  />
                  <button id="recalcFPS" type="button" class="secondary-btn small">
                    Calculate
                  </button>
                </div>
                <p class="perf-hint">
                  Type your real chrono speed, or tap <strong>Calc from Inputs</strong> to estimate.
                </p>
              </div>

              <!-- Windage editable box -->
              <div class="perf-box">
                <div class="perf-label-row">
                  <div class="metric-title">
                    <span class="perf-label">Crosswind</span>
                    <button class="info-btn small" type="button" data-info="windDrift">ⓘ</button>
                    <button class="math-btn" type="button" data-math="windDrift">∑</button>
                  </div>
                  <!-- <span class="perf-edit-pill">editable</span> -->
                </div>
                <div class="perf-input-row">
                  <input
                    id="windMph"
                    type="number"
                    inputmode="decimal"
                    step="0.5"
                    min="0"
                    value="0"
                  />
                  <span class="perf-unit">mph</span>
                </div>
                <p class="perf-hint">
                  Full-value side wind used for the drift estimate.
                </p>
              </div>
            </div>

            <!-- Row 2: Distance slider under both -->
            <div class="perf-slider-box">
              <div class="perf-slider-header">
                <div class="metric-title">
                  <span class="perf-slider-label">Distance</span>
                  <span class="perf-distance-value">
                    <span id="distanceValue">50</span> yd
                  </span>
                </div>
                <span class="perf-edit-pill">adjust</span>
              </div>
              <input
                id="distanceSlider"
                type="range"
                min="10"
                max="150"
                step="1"
                value="50"
              />
              <div class="distance-ticks" id="distanceTicks">
                <span>10</span><span>20</span><span>30</span><span>40</span>
                <span>50</span><span>60</span><span>70</span><span>80</span>
                <span>90</span><span>100</span><span>110</span><span>120</span>
                <span>130</span><span>140</span><span>150</span>
              </div>
            </div>
          </div>
        </section>

        <!-- PERFORMANCE CALCULATIONS -->
        <section class="card">
          <div class="card-header">
            <h2>Performance Calculations</h2>
            <button class="info-btn" type="button" data-info="performanceCalculations">ⓘ</button>
          </div>

          <!-- GAME EFFECTIVENESS / TARGET INSIGHTS FIRST -->
          <div class="subcard" id="gameCard" style="margin-top:0.25rem;">
            <div class="card-header compact" style="border-bottom:none;padding-bottom:0.25rem;margin-bottom:0.5rem;">
              <h3 id="gameCardTitle" style="margin:0;">Game Effectiveness</h3>
              <div style="display:flex;align-items:center;gap:0.35rem;">
                <button class="info-btn" type="button" data-info="gameEffectiveness">ⓘ</button>
                <button class="math-btn" type="button" data-math="game">∑</button>
              </div>
            </div>
        

            <!-- Hunting mode panel -->
            <div id="huntingMode">
              <div class="metric-grid">
                <div class="metric-tile">
                  <div class="metric-title">Small Game</div>
                  <div class="metric-main-value" style="font-size:2.2rem;">
                    <span id="smallGameStatus">–</span>
                  </div>
                  <p class="metric-note" style="font-size:0.8rem;color:var(--light);">
                    ~12+ ft-lbs KE (baseline).
                  </p>
                </div>

                <div class="metric-tile">
                  <div class="metric-title">Deer / Antelope</div>
                  <div class="metric-main-value" style="font-size:2.2rem;">
                    <span id="deerStatus">–</span>
                  </div>
                  <p class="metric-note" style="font-size:0.8rem;color:var(--light);">
                    ~25+ ft-lbs KE • ~0.30 slug·ft/s.
                  </p>
                </div>

                <div class="metric-tile">
                  <div class="metric-title">Elk / Large Game</div>
                  <div class="metric-main-value" style="font-size:2.2rem;">
                    <span id="elkStatus">–</span>
                  </div>
                  <p class="metric-note" style="font-size:0.8rem;color:var(--light);">
                    42–65 ft-lbs • 0.44–0.65 slug·ft/s.
                  </p>
                </div>

                <div class="metric-tile">
                  <div class="metric-title">Tough Game</div>
                  <div class="metric-main-value" style="font-size:2.2rem;">
                    <span id="mooseStatus">–</span>
                  </div>
                  <p class="metric-note" style="font-size:0.8rem;color:var(--light);">
                    65+ ft-lbs • 0.65+ slug·ft/s.
                  </p>
                </div>
              </div>

              <p id="gameMessage" class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.5rem;">
                Impact values are compared at the selected distance — a conservative “send it / adjust” helper, not a guarantee.
              </p>
            </div>

            <!-- Target / 3D mode panel -->
            <div id="targetMode" style="display:none; margin-top:0.75rem;">
              <div class="metric-grid">
                <div class="metric-tile">
                  <div class="metric-header-row" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem;">
                    <div class="metric-title">
                      <span>Group Stability</span>
                      <button class="info-btn small" type="button" data-info="groupStability">ⓘ</button>
                      <button class="math-btn" type="button" data-math="groupStability">∑</button>
                    </div>
                  </div>
                  <div class="metric-main-value" style="font-size:2.2rem;">
                    <span id="groupStabilityBadge">–</span>
                  </div>
                  <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                    Uses FPS, FOC, and GPI to approximate how forgiving this build should feel.
                  </p>
                </div>

                <div class="metric-tile">
                  <div class="metric-header-row" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem;">
                    <div class="metric-title">
                      <span>Flatness Score</span>
                      <button class="info-btn small" type="button" data-info="flatnessScore">ⓘ</button>
                      <button class="math-btn" type="button" data-math="flatnessScore">∑</button>
                    </div>
                  </div>
                  <div class="metric-main-value" style="font-size:2.2rem;">
                    <span id="flatnessScoreValue">–</span>
                  </div>
                  <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                    Based on extra drop from 20 → 60 yd (Very Flat / Flat / Curved).
                  </p>
                </div>
              </div>

              <div class="drop-table" style="margin-top:0.75rem;">
                <div class="metric-header-row" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.25rem;">
                  <div class="metric-title">
                    <span>Downrange Arrow Drop</span>
                    <button class="info-btn small" type="button" data-info="sightMarks">ⓘ</button>
                  </div>
                </div>
                <table class="data-table" id="dropTable">
                  <thead>
                    <tr>
                      <th>Distance</th>
                      <th>Drop (inches)</th>
                    </tr>
                  </thead>
                  <tbody>
                    <!-- filled by script -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <!-- Velocity + Peak Height row -->
          <div class="metric-grid" style="margin-top:1.25rem;">
            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Velocity @ <span id="velocityDistanceLabel">50</span> yd</span>
                  <button class="info-btn small" type="button" data-info="velocityAtDistance">ⓘ</button>
                  <button class="math-btn" type="button" data-math="velocity">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="velocityAtDistance">-</span>
                <span class="metric-unit" style="font-size:0.9rem;color:var(--light);">FPS</span>
              </div>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                Estimated speed at selected distance.
              </p>
            </div>

            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Peak Height</span>
                  <button class="info-btn small" type="button" data-info="peakHeight">ⓘ</button>
                  <button class="math-btn" type="button" data-math="peakHeight">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="peakHeightValue">-</span>
                <span class="metric-unit" style="font-size:0.9rem;color:var(--light);">ft</span>
              </div>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                Apex around <span id="peakDistanceValue">25</span> yd above a flat launch line.
              </p>
            </div>
          </div>

          <!-- KE / Time / Impact metrics -->
          <div class="metric-grid">
            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Launch KE</span>
                  <button class="info-btn small" type="button" data-info="launchKE">ⓘ</button>
                  <button class="math-btn" type="button" data-math="keLaunch">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="keValue">-</span>
                <span class="metric-unit" style="font-size:0.9rem;color:var(--light);">ft-lbs</span>
              </div>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                Energy at the bow.
              </p>
            </div>

            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Time to Impact</span>
                  <button class="info-btn small" type="button" data-info="timeToImpact">ⓘ</button>
                  <button class="math-btn" type="button" data-math="timeToImpact">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="timeToImpact">-</span>
                <span class="metric-unit" style="font-size:0.9rem;color:var(--light);">sec</span>
              </div>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                How long the arrow is in the air.
              </p>
            </div>

            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Impact KE</span>
                  <button class="info-btn small" type="button" data-info="impactKE">ⓘ</button>
                  <button class="math-btn" type="button" data-math="impactKE">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="impactKE">-</span>
                <span class="metric-unit" style="font-size:0.9rem;color:var(--light);">ft-lbs</span>
              </div>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                Energy at the selected distance.
              </p>
            </div>

            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Impact Momentum</span>
                  <button class="info-btn small" type="button" data-info="impactMom">ⓘ</button>
                  <button class="math-btn" type="button" data-math="impactMom">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="impactMom">-</span>
                <span class="metric-unit" style="font-size:0.9rem;color:var(--light);">slug·ft/s</span>
              </div>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                Momentum at the selected distance.
              </p>
            </div>
          </div>

          <!-- Stiffness / Wind drift row -->
          <div class="metric-grid">
            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Stiffness / Forgiveness</span>
                  <button class="info-btn small" type="button" data-info="stiffness">ⓘ</button>
                  <button class="math-btn" type="button" data-math="stiffness">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="stiffnessBadge">–</span>
              </div>
              <p id="stiffnessHint" class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                Enter draw, length, spine, and point weight to see a chart-style match.
              </p>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.25rem;">
                Effective draw weight ≈ <span id="effectiveDrawWeight">–</span> lb
              </p>
            </div>

            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>Wind Drift</span>
                  <button class="info-btn small" type="button" data-info="windDrift">ⓘ</button>
                  <button class="math-btn" type="button" data-math="windDrift">∑</button>
                </div>
              </div>
              <div class="metric-main-value" style="font-size:2rem;display:flex;align-items:baseline;gap:0.25rem;">
                <span id="windDriftValue">-</span>
                <span class="metric-unit" style="font-size:0.9rem;color:var(--light);">in</span>
              </div>
              <p class="metric-note" style="font-size:0.85rem;color:var(--light);margin-top:0.35rem;">
                Approximate side drift at the selected distance & wind.
              </p>
            </div>
          </div>
        </section>

        <!-- ARROW EFFICIENCY BETWEEN PERFORMANCE & BUILD SUMMARY -->
        <section class="card">
          <div class="card-header">
            <h2>Arrow Efficiency</h2>
            <button class="info-btn" type="button" data-info="arrowEfficiency">ⓘ</button>
          </div>

          <div class="metric-grid">
            <!-- GPP -->
            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>GPP</span>
                  <button class="info-btn small" type="button" data-info="gpp">ⓘ</button>
                  <button class="math-btn" type="button" data-math="gpp">∑</button>
                </div>
              </div>
              <div class="metric-main-value">
                <span id="gppValue">-</span>
                <span class="metric-unit">gr/lb</span>
              </div>
              <p id="gppHint" class="metric-note">
                <!-- script fills: light / all-around / heavy -->
              </p>
            </div>

            <!-- GPI -->
            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>GPI</span>
                  <button class="info-btn small" type="button" data-info="gpi">ⓘ</button>
                  <button class="math-btn" type="button" data-math="gpi">∑</button>
                </div>
              </div>
              <div class="metric-main-value">
                <span id="gpiValue">-</span>
                <span class="metric-unit">gr/in</span>
              </div>
              <p class="metric-note">
                Grains per inch based on finished arrow.
              </p>
            </div>

            <!-- Total Weight (TW) -->
            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>TW</span>
                  <button class="info-btn small" type="button" data-info="finalArrowWeight">ⓘ</button>
                  <button class="math-btn" type="button" data-math="tw">∑</button>
                </div>
              </div>
              <div class="metric-main-value">
                <span id="finalArrowWeight">-</span>
                <span class="metric-unit">gr</span>
              </div>
              <p class="metric-note">
                Total finished arrow weight.
              </p>
            </div>

            <!-- FOC -->
            <div class="metric-tile">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>FOC</span>
                  <button class="info-btn small" type="button" data-info="foc">ⓘ</button>
                  <button class="math-btn" type="button" data-math="foc">∑</button>
                </div>
              </div>
              <div class="metric-main-value">
                <span id="focValue">-</span>
                <span class="metric-unit">%</span>
              </div>
              <div class="foc-bar-wrapper" style="margin-top:0.25rem;">
                <div class="foc-bar-track" style="position:relative;height:10px;border-radius:999px;background:var(--bg);overflow:hidden;">
                  <div class="foc-bar-fill" id="focBarFill" style="position:absolute;left:0;top:0;bottom:0;border-radius:999px;background:var(--primary);opacity:0.25;width:0%;"></div>
                  <div class="foc-ideal-range" style="position:absolute;top:1px;bottom:1px;border-radius:999px;background:var(--success);opacity:0.25;left:40%;width:20%;"></div>
                  <div class="foc-marker" id="focMarker" style="position:absolute;top:-4px;width:0;height:18px;border-left:2px solid var(--primary);"></div>
                </div>
                <div class="foc-bar-labels" style="display:flex;justify-content:space-between;font-size:0.8rem;color:var(--light);margin-top:0.25rem;">
                  <span>0%</span>
                  <span>30%</span>
                </div>
              </div>
              <p id="focHint" class="metric-note">
                <!-- script sets guidance -->
              </p>
            </div>

            <!-- Arrow Weight Composition (AWC) spans both columns -->
            <div class="metric-tile awc-wide">
              <div class="metric-header-row">
                <div class="metric-title">
                  <span>AWC</span>
                  <button class="info-btn small" type="button" data-info="composition">ⓘ</button>
                  <button class="math-btn" type="button" data-math="awc">∑</button>
                </div>
              </div>
              <div class="comp-bar-track" style="position:relative;height:10px;border-radius:999px;background:var(--bg);overflow:hidden;display:flex;">
                <div class="comp-seg comp-seg-shaft" id="compShaftSeg" style="height:100%;"></div>
                <div class="comp-seg comp-seg-point" id="compPointSeg" style="height:100%;"></div>
                <div class="comp-seg comp-seg-other" id="compOtherSeg" style="height:100%;"></div>
              </div>
              <p id="compTotalLabel" class="metric-note" style="margin-top:0.35rem;">
                Shaft: 0% • Point: 0% • Components: 0%
              </p>
              <div class="comp-legend">
                <span><span class="comp-dot comp-dot-shaft"></span><span id="shaftPctLabel">Shaft: 0%</span></span>
                <span><span class="comp-dot comp-dot-point"></span><span id="pointPctLabel">Point: 0%</span></span>
                <span><span class="comp-dot comp-dot-other"></span><span id="compPctLabel">Comp.: 0%</span></span>
              </div>
            </div>
          </div>
        </section>

        <!-- BUILD SUMMARY LAST -->
        <section class="card">
          <div class="card-header">
            <h2>Build Summary</h2>
            <button class="info-btn" type="button" data-info="buildSummary">ⓘ</button>
          </div>

          <div class="build-summary" id="summaryTable">
            <!-- script injects <table>...</table> -->
          </div>
          <button id="copySummary" type="button" class="btn-small" style="margin-top:0.75rem;">
            Copy
          </button>
        </section>

        <!-- Patreon / Support link -->
        <a
          class="patreon-btn"
          href="https://patreon.com/ArrowTuneCalculator?utm_medium=unknown&utm_source=join_link&utm_campaign=creatorshare_creator&utm_content=copyLink"
          target="_blank"
          rel="noopener noreferrer"
        >
          Support the project on Patreon ❤️
        </a>
      </div> <!-- end outputs-column -->
    </div> <!-- end container -->

    <!-- Math Popup -->
    <div class="info-overlay" id="mathOverlay">
      <div class="info-panel" id="mathPanel">
        <button class="info-close" id="mathClose">&times;</button>
        <h2>Math Details</h2>
        <div id="mathContent"></div>
      </div>
    </div>

    <!-- Info Popup -->
    <div class="info-overlay" id="infoOverlay">
      <div class="info-panel" id="infoPanel">
        <button class="info-close" id="infoClose">&times;</button>
        <h2 id="infoTitle"></h2>
        <div id="infoBody"></div>
      </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- SCRIPT SECTION BEGIN -->
<script>
/* ============================================================
   VARIABLES + UTILITIES
============================================================ */
const $ = (id) => document.getElementById(id);

// Inputs
const bowModelEl = $("bowModel");
const iboEl = $("iboRating");
const drawWeightEl = $("drawWeight");
const drawLengthEl = $("drawLength");

const stringSimpleEl = $("stringWeightSimple");
const toggleStringEl = $("toggleString");
const peepEl = $("peepWeight");
const dloopEl = $("dloopWeight");
const kisserEl = $("kisserWeight");
const silencersEl = $("silencersWeight");
const stringAdvTotalEl = $("stringTotal");

const arrowNameEl = $("arrowName");
const arrowSpineEl = $("arrowSpine");
const arrowLengthEl = $("arrowLength");
const totalArrowWeightSimpleEl = $("totalArrowWeightSimple");
const pointWeightEl = $("pointWeight");
const balancePointEl = $("balancePoint");

const toggleArrowEl = $("toggleArrow");
const bareShaftEl = $("bareShaft");
const nockWeightEl = $("nockWeight");
const wrapWeightEl = $("wrapWeight");
const vaneWeightEachEl = $("vaneWeightEach");
const vaneCountEl = $("vaneCount");
const insertWeightEl = $("insertWeight");
const glueWeightEl = $("glueWeight");

const applicationEl = $("application");

const notesEl = $("notes");

// Performance inputs
const distanceSliderEl = $("distanceSlider");
const windMphEl = $("windMph");

// Outputs
const fpsEl = $("actualFPS");
const fpsSourceEl = $("fpsSource");
const gppValueEl = $("gppValue");
const gpiValueEl = $("gpiValue");
const twEl = $("finalArrowWeight");

const focValueEl = $("focValue");
const focBarFillEl = $("focBarFill");
const focMarkerEl = $("focMarker");
const focHintEl = $("focHint");

const compShaftSegEl = $("compShaftSeg");
const compPointSegEl = $("compPointSeg");
const compOtherSegEl = $("compOtherSeg");
const compTotalLabelEl = $("compTotalLabel");
const shaftPctLabelEl = $("shaftPctLabel");
const pointPctLabelEl = $("pointPctLabel");
const compPctLabelEl = $("compPctLabel");

const velocityAtDistanceEl = $("velocityAtDistance");
const peakHeightValueEl = $("peakHeightValue");
const peakDistanceValueEl = $("peakDistanceValue");
const keValueEl = $("keValue");
const timeToImpactEl = $("timeToImpact");
const impactKEEl = $("impactKE");
const impactMomEl = $("impactMom");
const windDriftValueEl = $("windDriftValue");
const distanceValueEl = $("distanceValue");

// Spine + Game + Target Outputs
const stiffnessBadgeEl = $("stiffnessBadge");
const stiffnessHintEl = $("stiffnessHint");
const effDwEl          = $("effectiveDrawWeight");

const smallStatusEl = $("smallGameStatus");
const deerStatusEl = $("deerStatus");
const elkStatusEl = $("elkStatus");
const mooseStatusEl = $("mooseStatus");
const gameMessageEl = $("gameMessage");

// Target Insights – tolerate different ID variants
const groupStabilityBadgeEl =
  $("groupStabilityBadge") ||
  $("groupStabilityValue") ||
  $("groupStability");

const flatnessScoreValueEl =
  $("flatnessScoreValue") ||
  $("flatnessScore") ||
  $("flatnessValue");

const dropTableEl = $("dropTable").querySelector("tbody");

// Build Summary
const summaryTableEl = $("summaryTable");
const copySummaryBtn = $("copySummary");

const infoOverlay = $("infoOverlay");
const infoPanel = $("infoPanel");
const infoTitle = $("infoTitle");
const infoBody = $("infoBody");
const infoClose = $("infoClose");

const mathOverlay = $("mathOverlay");
const mathPanel = $("mathPanel");
const mathClose = $("mathClose");
const mathContent = $("mathContent");

// TOAST
const toast = $("toast");

/* ============================================================
   INFO CONTENT
============================================================ */

const INFO_CONTENT = {
  buildName: `
    <h2>Build Name</h2>
    <p>
      A human-friendly label for this bow + arrow setup. It’s used as the name
      when you save, load, and compare builds.
    </p>
    <p>
      The <strong>Suggest</strong> button auto-builds a name using date, bow model,
      draw weight, arrow name, and total arrow weight so your builds stay organized.
    </p>
  `,
  bowModel: `
    <h2>Bow Model</h2>
    <p>
      The make and model of your bow (e.g., "2025 Hoyt RX-9").
      This is saved with the build and used in the suggested build name.
    </p>
    <p>
      It doesn’t change the math directly, but it makes it easier to track which
      numbers go with which bow.
    </p>
  `,
  iboRating: `
    <h2>IBO / ATA Speed Rating</h2>
    <p>
      The manufacturer’s advertised max speed in feet per second (FPS), usually at
      70 lb draw, 30&quot; draw length, and a 350 gr arrow.
    </p>
    <p>
      This app uses that rating to <strong>estimate your real-world launch FPS</strong>
      until you replace it with chronograph data.
    </p>
  `,
  drawWeight: `
    <h2>Draw Weight (lbs)</h2>
    <p>
      How many pounds you pull at full draw. It controls how much energy the bow can
      put into the arrow.
    </p>
    <p>
      In this calculator, draw weight is used with total arrow weight to compute
      <strong>GPP (grains per pound)</strong>, which helps classify your arrow as
      light, all-around, or heavy for hunting and penetration.
    </p>
  `,
  drawLength: `
    <h2>Draw Length (inches)</h2>
    <p>
      How far you pull the string at full draw (your personal power stroke).
      Factory IBO speeds assume 30&quot; draw; shorter draws usually shoot slower.
    </p>
    <p>
      This value is saved with your build so your FPS, KE, and trajectory can be
      interpreted in the context of <em>your</em> form, not just factory specs.
    </p>
  `,
  stringWeightSimple: `
    <h2>String Add-ons (grains)</h2>
    <p>
      The combined weight of everything on your string (peep, loop, kisser, silencers),
      entered as a single number.
    </p>
    <p>
      This is used in the launch FPS estimate. Heavier strings generally reduce
      real-world FPS slightly compared to the IBO rating.
    </p>
    <p>
      Turn on <strong>Advanced String Components</strong> if you want to enter each
      piece separately.
    </p>
  `,
  application: `
    <h2>Application</h2>
    <p>
      High-level use for this setup: Target/3D, Hunting, or Other. This is saved in your
      build and is used to switch between <strong>Game Effectiveness</strong> (Hunting)
      and <strong>Target Insights</strong> (Target / Other).
    </p>
    <p>
      It does not change the underlying physics, but it changes how the results are
      summarized for you.
    </p>
  `,
  toggleString: `
    <h2>Advanced String Components</h2>
    <p>
      Turn this on if you want to enter the weights of your peep, D-loop, kisser, and
      silencers separately.
    </p>
    <p>
      When enabled, the app <strong>sums the detailed values</strong> and uses that
      total in the FPS estimate instead of the single String Add-ons field.
    </p>
  `,
  peepWeight: `
    <h2>Peep Weight</h2>
    <p>
      Weight of your peep sight in grains. Included in total string weight and the
      launch FPS estimate when Advanced String Components are enabled.
    </p>
  `,
  dloopWeight: `
    <h2>D-Loop Weight</h2>
    <p>
      Total weight of your D-loop in grains. Included in total string weight and the
      launch FPS estimate in Advanced mode.
    </p>
  `,
  kisserWeight: `
    <h2>Kisser Button Weight</h2>
    <p>
      Weight of your kisser button in grains. Included in total string weight and FPS
      estimation when using Advanced String Components.
    </p>
  `,
  silencersWeight: `
    <h2>Silencers Weight</h2>
    <p>
      Combined weight of all string silencers in grains. Included in total string
      weight and launch FPS estimation in Advanced mode.
    </p>
  `,
  arrowName: `
    <h2>Arrow Name</h2>
    <p>
      A label for the arrow itself (e.g., "Easton Axis 5mm 300 spine").
      Used in the suggested build name and saved with the build.
    </p>
    <p>
      It doesn’t change calculations, but makes it much easier to track which shaft
      you’re tuning.
    </p>
  `,
  arrowSpine: `
    <h2>Arrow Spine Stiffness</h2>
    <p>
      The <strong>static spine rating</strong> printed on your shaft (e.g., 250, 300, etc).
    </p>
    <p>
      The Stiffness / Forgiveness card compares this value to a chart-style
      recommendation based on draw weight, arrow length, and point weight.
    </p>
    <p>
      If it shows <strong>Adjust</strong>, consider:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>moving closer or limiting your max range</li>
      <li>changing point weight</li>
      <li>moving to a stiffer or weaker spine as indicated</li>
    </ul>
  `,
  arrowLength: `
    <h2>Arrow Length</h2>
    <p>
      Measured from the throat of the nock to the <strong>end of the shaft</strong>
      (not including the point).
    </p>
    <p>
      This is used for <strong>GPI (grains per inch)</strong> and for the
      <strong>FOC calculation</strong> so the app knows the total shaft length
      your balance point is measured over.
    </p>
  `,
  totalArrowWeightSimple: `
    <h2>Total Arrow Weight (Simple Mode)</h2>
    <p>
      The full arrow weight in grains (shaft + insert/outsert + vanes + wrap + nock + point),
      entered as a single number.
    </p>
    <p>
      When Advanced Arrow Components is <strong>off</strong>, this value drives all
      weight-based metrics: GPP, KE, momentum, impact energy, and Build Summary.
    </p>
    <p>
      Turn on Advanced mode if you want the app to calculate total weight from individual components.
    </p>
  `,
  pointWeight: `
    <h2>Point Weight</h2>
    <p>
      Weight of your field point or broadhead in grains.
    </p>
    <p>
      Used in the <strong>FOC calculation</strong>, the
      <strong>Arrow Weight Composition</strong> bar, and total arrow weight
      when Advanced mode is enabled.
    </p>
  `,
  balancePoint: `
    <h2>Balance Point from Nock</h2>
    <p>
      Measure from the nock throat (string contact point) to the point where the
      arrow balances perfectly on a finger or edge.
    </p>
    <p>
      This value, together with arrow length, is used to compute
      <strong>FOC (Front of Center)</strong>.
    </p>
  `,
  toggleArrow: `
    <h2>Advanced Arrow Components</h2>
    <p>
      Enable this if you want to enter the weights of the shaft, vanes, wrap, insert,
      nock, and glue separately.
    </p>
    <p>
      In Advanced mode, the app <strong>adds up all components plus point weight</strong>
      to get total arrow weight instead of using the single Total Arrow Weight field.
    </p>
  `,
  bareShaft: `
    <h2>Bare Shaft Weight</h2>
    <p>
      Weight of the cut shaft only (no insert, vanes, wrap, nock, or point).
    </p>
    <p>
      Used in the total arrow weight and the shaft portion of the
      <strong>Arrow Weight Composition</strong> bar.
    </p>
  `,
  nockWeight: `
    <h2>Nock System Weight</h2>
    <p>
      Weight of your nock or pin-nock system in grains.
    </p>
    <p>
      Included in total arrow weight and counted as part of “Components” in the
      Arrow Weight Composition bar.
    </p>
  `,
  wrapWeight: `
    <h2>Wrap Weight</h2>
    <p>
      Total weight of any arrow wrap or cap wrap in grains.
    </p>
    <p>
      Included in total arrow weight and treated as “Components” in the composition bar.
    </p>
  `,
  vaneWeightEach: `
    <h2>Vane Weight (each)</h2>
    <p>
      Weight of a single vane or feather in grains.
    </p>
    <p>
      The app multiplies this by <strong>Vane Count</strong>, then adds it to total arrow
      weight as part of “Components”.
    </p>
  `,
  vaneCount: `
    <h2>Vane Count</h2>
    <p>
      How many vanes or feathers are on the arrow (3-fletch, 4-fletch, etc.).
    </p>
    <p>
      Used with Vane Weight (each) to compute total fletching weight for the
      arrow weight and composition breakdown.
    </p>
  `,
  insertWeight: `
    <h2>Insert / Outsert Weight</h2>
    <p>
      Weight of your insert or outsert system in grains.
    </p>
    <p>
      Included in total arrow weight and treated as “Components” in the
      Arrow Weight Composition bar.
    </p>
  `,
  glueWeight: `
    <h2>Glue / Pin Nock Weight</h2>
    <p>
      An estimate of the combined weight of glue, pin bushings, and any small
      hardware at the nock or insert end.
    </p>
    <p>
      Included in total arrow weight and the “Components” portion of the composition bar.
    </p>
  `,
  notes: `
    <h2>Notes</h2>
    <p>
      Free-form notes saved with this build — great for recording paper tune results,
      broadhead groups, chrono strings, or field observations.
    </p>
    <p>
      Notes are stored in your saved build so you can revisit why a setup worked
      (or didn’t) later.
    </p>
  `,
  arrowEfficiency: `
    <h2>Arrow Efficiency</h2>
    <p>
      A quick overview of how your bow’s energy, arrow weight, and balance are working together.
    </p>
    <p>
      This section summarizes your main tuning metrics: launch speed, GPP, GPI, total arrow weight,
      FOC, and component breakdown.
    </p>
  `,
    peakHeight: `
    <h2>Peak Height vs Downrange Drop</h2>
    <p>
      Most archery charts talk about <strong>drop</strong> — how far the arrow is
      <em>below your line of sight</em> (your peep–to–pin line) at 30, 40, 50+ yards.
      That line of sight is tilted slightly upward when you zero at a distance like
      20 yards.
    </p>
    <p>
      <strong>Peak Height</strong> in this app uses a different reference:
      it measures how high the arrow’s path gets above a
      <strong>horizontal launch line</strong> — a flat line shooting straight out
      of the bow at release.
    </p>
    <p>
      Under the hood, the calculator:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>Assumes level ground and no wind.</li>
      <li>Solves for the launch angle that would land the arrow at your chosen distance.</li>
      <li>Uses that angle to find the highest point of the arc above the launch line.</li>
      <li>Assumes the peak happens roughly halfway to the target in yards.</li>
    </ul>
    <p>
      That’s why Peak Height:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>Shows how much “ceiling” you need to clear brush, branches, or blind windows.</li>
      <li>Gives a feel for how “arched” the flight really is at that distance.</li>
      <li>
        Won’t match sight–tape drop numbers one-for-one —
        they’re measured from a <em>tilted sight line</em>, not a flat launch line.
      </li>
    </ul>
    <p>
      Use it as a <strong>sanity check</strong> for clearance and overall arc shape,
      not as a replacement for your actual sight tape.
    </p>
  `,
  yourSettings: `
    <h2>Your Settings</h2>
    <p>
      This section contains the <strong>inputs you can directly adjust</strong> to shape 
      the rest of the performance calculations.
    </p>

    <p><strong>Launch FPS</strong> – Enter your chronographed speed, or let the app estimate it from your IBO rating with simple rule-of-thumb adjustments for draw weight, draw length, arrow weight, and string add-ons. Always trust your chrono over the estimate when you have it.</p>

    <p><strong>Crosswind (mph)</strong> – A full-value side wind used for the Wind Drift estimate. Changing this helps visualize how stable your arrow is downrange.</p>

    <p><strong>Distance Slider</strong> – Sets the target yardage for all calculations below, including velocity at distance, peak height, time of flight, energy, momentum, and effectiveness.</p>

    <p>
      Think of this group as your <strong>primary tuning controls</strong>: adjust them to see 
      how your build behaves in real-world shooting conditions.
    </p>
  `,
    velocitySection: `
    <h2>Performance @ Distance</h2>
    <p>
      This card shows how your arrow behaves at the <strong>current distance</strong>
      you’ve set (with the slider or by typing a yardage).
    </p>
    <p>It pulls everything together from your build:</p>
    <ul style="margin-left:1.25rem;">
      <li><strong>Velocity</strong> – estimated arrow speed at that yardage.</li>
      <li><strong>Peak Height</strong> – how high the arrow arcs above a
          level launch line before dropping back toward the target.</li>
      <li><strong>Time to Impact</strong> – how long the arrow is in the air.</li>
      <li><strong>Impact KE & Momentum</strong> – energy and momentum carried into the target.</li>
      <li><strong>Wind Drift</strong> – side drift from a full-value crosswind you set in mph.</li>
    </ul>
    <p>
      Use this as your <strong>“real-world feel” panel</strong>:
      slide (or type) the distance, tweak launch FPS or arrow weight, and watch how
      the arc, impact numbers, and drift change together.
    </p>
    <p>
      The math behind each tile is available with the small 
      <strong>Math</strong> buttons, so you can see the exact formulas and
      how your numbers plug into them.
    </p>
  `,
    performance: `
    <h2>Performance @ Distance</h2>
    <p>
      Same as the <strong>Performance @ Distance</strong> card: it shows
      velocity, arc height, time-of-flight, impact KE/momentum, and wind drift
      at the distance you’ve set.
    </p>
    <p>
      Adjust the yardage, launch FPS, or arrow build and watch how the
      numbers change. Use it as a quick, visual way to compare setups.
    </p>
  `,
  performanceCalculations: `
    <h2>Performance Calculations</h2>
    <p>
      These are the physics-based estimates for how your arrow flies and hits
      at the distance you’ve chosen. They pull directly from your launch FPS,
      arrow weight, and the simple ballistic models described in each Math popup.
    </p>
    <p>
      Treat them as <strong>sanity checks and comparison tools</strong>, not
      replacements for real shooting and sight tape work.
    </p>
  `,
  actualFPS: `
    <h2>FPS</h2>
    <p>
      The speed the arrow leaves the bow, in feet per second.
    </p>
    <p>
      If you don’t have chronograph data yet, the app makes a <strong>ballpark estimate</strong>
      from your IBO rating and simple adjustments for draw weight, draw length, arrow weight,
      and string add-ons.
    </p>
    <p>
      It’s meant to get you close enough to compare builds and see trends – not to replace a
      real chrono. When you do have chrono numbers, enter them here and the calculator will
      treat that as the source of truth.
    </p>
  `,
  gpp: `
    <h2>GPP (Grains per Pound)</h2>
    <p>
      Total arrow weight divided by draw weight (grains per pound of draw).
    </p>
    <p>
      It’s a simple way to see if your arrow is light, all-around, or heavy for your bow.
      The app uses this to give guidance on where your setup sits in that spectrum.
    </p>
  `,
  gpi: `
    <h2>GPI (Grains per Inch)</h2>
    <p>
      Average grains per inch of length based on your total arrow weight and arrow length.
    </p>
    <p>
      Useful for comparing shafts and seeing how heavy your finished arrow is per inch,
      especially when switching between cut lengths.
    </p>
  `,
  finalArrowWeight: `
    <h2>TW (Total Weight)</h2>
    <p>
      The final arrow weight in grains (shaft + components + point).
    </p>
    <p>
      This drives nearly every other output: GPP, KE, momentum, impact, and the composition bar.
      Getting this number accurate is critical for realistic results.
    </p>
  `,
  foc: `
    <h2>FOC (Front of Center)</h2>
    <p>
      FOC shows how far forward the balance point is, expressed as a percentage of arrow length.
      More weight toward the front usually helps broadhead stability and penetration.
    </p>
    <p>
      The bar shows your value on a 0–30% scale, with a highlighted band for
      <strong>12–18%</strong>, a common sweet spot for many hunting setups.
    </p>
  `,
  composition: `
    <h2>AWC (Arrow Weight Composition)</h2>
    <p>
      A visual breakdown of how your arrow’s total weight is split between
      <strong>shaft</strong>, <strong>point</strong>, and other components.
    </p>
    <p>
      This is helpful for understanding where your mass is concentrated, and how changing
      inserts, vanes, or point weight affects overall build and FOC.
    </p>
  `,
  velocitySection: `
    <h2>Performance @ Distance</h2>
    <p>
      Use the slider to set a target distance. The app then estimates:
      arrow speed at that distance, peak height of the arc, time of flight,
      and impact energy/momentum.
    </p>
    <p>
      Great for visualizing how your arrow behaves at different ranges and 
      how much it slows down over distance.
    </p>
  `,
    velocityAtDistance: `
    <h2>Velocity</h2>
    <p>
      Estimated arrow speed at the selected yardage based on your launch FPS and
      a simple decay model that <strong>scales with arrow weight</strong>.
      Lighter arrows (lower GPP) shed speed faster; heavier arrows hang onto
      speed a bit longer.
    </p>
    <p>
      Under the hood the calculator uses an exponential curve:
      v(d) = v₀ × e^(−d / L), where <strong>L</strong> is an effective
      “speed-retention distance” in yards. L is tuned from your
      grains-per-pound (GPP) so it behaves like common hunting setups:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>~5–6 GPP → shorter L (faster speed loss)</li>
      <li>~7 GPP → mid L (neutral reference)</li>
      <li>~8–9 GPP → longer L (better speed retention)</li>
    </ul>
    <p>
      This feeds the impact KE and momentum calculations and gives you a feel
      for how much speed you’re giving up as range increases.
    </p>
  `,
    timeToImpact: `
    <h2>Time to Impact</h2>
    <p>
      How long the arrow is in the air before it reaches the target at the
      current distance setting.
    </p>
    <p>
      The calculator uses a simple <strong>average–velocity model</strong>:
      it looks at your launch FPS and your estimated velocity at the chosen
      distance, averages them, and then divides the total distance by that
      average speed.
    </p>
    <p>
      That keeps the math intuitive:
      faster setups have shorter times, slower or heavy–arrow builds stay in
      the air longer, and anything that robs speed (distance, drag, extra
      weight) stretches the time slightly.
    </p>
    <p>
      Treat this as a <strong>ballpark flight time</strong> to help you think
      about string jump and animal movement, not a frame–by–frame slow-motion
      measurement.
    </p>
  `,
  impactKE: `
    <h2>Impact Kinetic Energy</h2>

    <p>
      <strong>Impact KE</strong> tells you how much usable energy the arrow is still carrying
      <em>at the selected target distance</em>. Because arrows slow down in flight,
      impact KE is always lower than launch KE — sometimes dramatically lower on lighter setups.
    </p>

    <p>This value comes from:</p>
    <ul style="margin-left:1.25rem;">
      <li>Your total arrow weight (in grains)</li>
      <li>Your estimated velocity at the chosen distance</li>
    </ul>

    <p>
      Heavier arrows lose speed more slowly and retain more KE downrange.  
      Lighter arrows start fast but shed energy quickly.
    </p>

    <h3 style="margin-top:1rem;">Why Impact KE Matters</h3>
    <p>
      This number feeds into the <strong>Game Effectiveness</strong> guidance.  
      It is compared against conservative minimum KE guidelines for different classes of game.
      These are not laws — but they're common reference points used by bowhunters.
    </p>

    <p>
      High impact KE generally means:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>Better penetration potential</li>
      <li>More forgiving momentum at imperfect angles</li>
      <li>Reduced sensitivity to heavy clothing, ribs, or shoulder muscle</li>
    </ul>

    <h3 style="margin-top:1rem;">How We Compute It</h3>
    <p>
      Velocity at distance comes from the arrow’s modeled speed decay over the selected yardage.  
      Once we have the impact velocity, we apply the standard archery KE formula.
    </p>

    <p>
      KE drops quickly if:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>The arrow is light (low momentum)</li>
      <li>The shot distance is long</li>
      <li>Your launch FPS is modest</li>
    </ul>

    <p>
      Treat Impact KE as a <strong>sanity check</strong> — not a strict requirement.
      Broadhead type, tuning quality, and shot placement matter more than any single number.
    </p>
  `,
  impactMom: `
    <h2>Impact Momentum</h2>
    <p>
      Momentum measures how much “push” the arrow carries into the target.  
      While kinetic energy favors lighter, faster arrows, <strong>momentum favors mass</strong>.
    </p>

    <p><strong>Why it matters:</strong></p>
    <ul style="margin-left:1.25rem;">
      <li>Heavier arrows lose speed more slowly downrange.</li>
      <li>Heavier arrows maintain a higher portion of their launch momentum.</li>
      <li>Momentum correlates strongly with penetration and broadhead stability.</li>
    </ul>

    <p><strong>Interpretation:</strong></p>
    <ul style="margin-left:1.25rem;">
      <li>Values around <strong>0.20–0.30 slug·ft/s</strong> are typical for small-game setups.</li>
      <li><strong>0.30–0.45</strong> is common for whitetail / antelope rigs.</li>
      <li><strong>0.45–0.60+</strong> is common for elk-strength or heavier builds.</li>
    </ul>

    <p>
      This calculator uses your <strong>impact velocity</strong> (after simulated drag loss)  
      and your <strong>total arrow weight</strong> to compute real downrange momentum.
    </p>
  `,
  stiffness: `
  <h2>Stiffness / Forgiveness</h2>

  <p>
    This tile compares your arrow’s <strong>static spine rating</strong> (e.g., 250, 300, 340)
    against a <strong>chart-style recommended spine</strong> based on draw weight, arrow
    length, and point weight. It acts like a modernized version of the old Easton
    selection charts.
  </p>

  <p>
    The calculator builds an <strong>effective load number</strong> from your setup:
  </p>

  <ul style="margin-left:1.25rem;">
    <li>Heavier draw weights increase required stiffness</li>
    <li>Longer arrows increase required stiffness</li>
    <li>Heavier point weights increase required stiffness</li>
  </ul>

  <p>
    That load is mapped to a <strong>recommended spine</strong> using a tuned constant,
    giving a realistic match to how shafts behave in the field.
  </p>

  <p><strong>Interpretation:</strong></p>
  <ul style="margin-left:1.25rem;">
    <li><strong>Good</strong> — Your actual spine is very close to the recommended number.
        Tuning should be straightforward, broadheads should group well, and the setup
        should be forgiving.</li>

    <li><strong>Adjust (Stiff)</strong> — Your arrow spine number is <em>lower</em> than
        recommended (e.g., 250 vs 300). Arrow is too stiff. You can add point weight,
        increase arrow length slightly, or move to a weaker spine.</li>

    <li><strong>Adjust (Weak)</strong> — Your arrow spine number is <em>higher</em> than
        recommended (e.g., 400 vs 300). Arrow is too weak. Consider shorter arrows,
        lighter points, or a stiffer shaft.</li>
  </ul>

  <p>
    This match check does <strong>not</strong> replace paper tuning, bareshaft tuning,
    broadhead flight testing, or dynamic spine testing — but it gives a solid
    chart-correct starting point for tuning and troubleshooting.
  </p>

  <p>
    Use this to see which arrow builds will tune easiest and fly the most
    consistently with fixed-blade broadheads.
  </p>
`,
  windDrift: `
    <h2>Wind Drift</h2>
    <p>
      Wind drift estimates how far a crosswind can push your arrow sideways by the time it reaches the target.
      Because arrows are relatively light and slow compared to bullets, even moderate wind can move them several inches.
    </p>

    <p><strong>What affects wind drift?</strong></p>
    <ul style="margin-left:1.25rem;">
      <li><strong>Distance</strong> — the farther the arrow travels, the more time wind has to act on it.</li>
      <li><strong>Wind speed</strong> — higher mph means stronger sideways force.</li>
      <li><strong>Arrow weight</strong> — heavier arrows resist wind better.</li>
      <li><strong>Arrow shape & FOC</strong> — higher FOC and lower drag designs drift slightly less.</li>
    </ul>

    <p><strong>How to use it:</strong></p>
    <p>
      This is not a ballistic solver — it's a practical field estimate so you can compare
      <em>light vs heavy arrows</em> and <em>calm vs windy conditions</em>.
      Use it to understand how much your setup may drift at 40–60 yd in a typical 5–15 mph crosswind.
    </p>
  `,
  gameEffectiveness: `
    <h2>Game Effectiveness / Target Insights</h2>
    <p>
      In <strong>Hunting</strong> mode, this compares your impact <strong>kinetic energy</strong> and
      <strong>momentum</strong> at the chosen distance against conservative thresholds
      for four game classes.
    </p>
    <p>
      If a tile shows <strong>Adjust</strong>, think in terms of options:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>move closer to reduce distance and drift</li>
      <li>increase arrow weight or optimize FOC</li>
      <li>tune your spine (stiffer or weaker as indicated)</li>
    </ul>
    <p>
      In <strong>Target / 3D / Other</strong> modes, this panel switches to 
      <strong>Target Insights</strong>:
    </p>
    <ul  style="margin-left:1.25rem;">
      <li>Group Stability badge (Tight / Average) based on FPS, FOC, and GPI.</li>
      <li>Flatness score using a simple 60 yd arc approximation.</li>
      <li>Downrange Arrow Drop simulator: relative drop from a 20 yd zero at 30–70 yd.</li>
    </ul>
    <p>
      Think of both views as <strong>sanity checks and tuning helpers</strong>, not guarantees.
      Broadhead design, shot angle, flight quality, and shot placement still matter more
      than any single number.
    </p>
  `,
  groupStability: `
    <h2>Group Stability (Target / 3D)</h2>
    <p>
      Group Stability is a <strong>forgiveness indicator</strong> meant to help target/3D shooters
      understand how consistent a setup should feel when the bow is well tuned and form is solid.
    </p>
    
    <p>It evaluates how well three factors work together:</p>
    <ul style="margin-left:1.25rem;">
      <li><strong>Launch FPS</strong> – higher speeds reduce hold time and tighten groups.</li>
      <li><strong>FOC</strong> – mid-range FOC (≈12–18%) usually stabilizes broadheads and fletching quickly.</li>
      <li><strong>GPI</strong> – lighter arrows (lower grains per inch) accelerate faster and arc less.</li>
    </ul>

    <p><strong>How the calculator interprets these:</strong></p>
    <ul style="margin-left:1.25rem;">
      <li>FPS ≥ <strong>270</strong> → strong for target/3D forgiveness</li>
      <li>FOC between <strong>12% and 18%</strong> → ideal balance & point control</li>
      <li>GPI ≤ <strong>9.5 gr/in</strong> → not overly heavy per inch; stabilizes quickly</li>
    </ul>

    <p>
      When all three fall in their optimal zones, the badge reads 
      <strong style="color:var(--success);">Tight</strong>.
      If one or more are outside the zone, it reads 
      <strong style="color:var(--warning);">Average</strong>.
    </p>

    <p>
      This metric is not meant as a guarantee of group size — it’s a 
      <strong>relative comparison tool</strong> between arrow builds, letting you see which setups
      should feel more forgiving at the same distance.
    </p>
  `,
  flatnessScore: `
    <h2>Flatness Score (20 → 60 yd)</h2>
    <p>
      Flatness looks at <strong>how tall your arc needs to be by 60 yards</strong>
      when you are zeroed at 20 yards.
    </p>
    <p>
      Under the hood, the calculator:
    </p>
    <ul style="margin-left:1.25rem;">
      <li>Uses your launch FPS to model gravity drop at 20 and 60 yd.</li>
      <li>Measures the extra drop from <strong>20 → 60 yd</strong>.</li>
      <li>Turns that into an effective arc height and maps it to a label.</li>
    </ul>
    <p>
      Roughly:
    </p>
    <ul style="margin-left:1.25rem;">
      <li><strong>Very Flat</strong> – effective arc &lt; ~3 ft by 60 yd</li>
      <li><strong>Flat</strong> – ~3–4.5 ft of effective arc</li>
      <li><strong>Curved</strong> – &gt; ~4.5 ft of effective arc</li>
    </ul>
    <p>
      Use this as a <strong>comparison tool</strong> between builds — it’s not meant
      to replace a dedicated sight tape or ballistic solver, just to show whether a
      build is more “flat bow” or “loopy 3D rig” by the time it gets to 60 yards.
    </p>
  `,
  sightMarks: `
    <h2>Downrange Arrow Drop Simulator</h2>
    <p>
      This table shows the <strong>relative drop</strong> (in inches) between a
      <strong>20 yd zero</strong> and longer distances (30–70 yd), using the same
      simple ballistic model as the trajectory and time-of-flight estimates.
    </p>
    <p>
      Think of it as: if you are perfectly sighted at 20 yd, how much farther the
      arrow has to fall at 30, 40, 50, 60, and 70 yd. Bigger numbers mean more
      sight gap and wider pin spacing.
    </p>
  `,
  buildSummary: `
    <h2>Build Summary</h2>
    <p>
      A snapshot of all the key inputs and outputs for your current setup:
      bow specs, arrow specs, FOC, GPP/GPI, launch speed, energy, momentum,
      and impact numbers at the selected distance.
    </p>
    <p>
      The <strong>Copy</strong> button copies this table as text so you can paste it
      into notes, messages, forums, or spreadsheets.
    </p>
  `
};

/* ============================================================
   EASY HELPERS
============================================================ */

let toastTimer;
function showToast(msg) {
  toast.textContent = msg;
  toast.style.opacity = '1';
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => { toast.style.opacity = '0'; }, 2000);
}

const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
const toGrains = (g) => parseFloat(g) || 0;
const toNumber = (v) => parseFloat(v) || 0;

/* ============================================================
   DARK MODE
============================================================ */

const darkToggle = $("darkModeToggle");
if (
  localStorage.getItem('dark') === '1' ||
  (!localStorage.getItem('dark') && matchMedia('(prefers-color-scheme: dark)').matches)
) {
  document.body.classList.add('dark');
  darkToggle.checked = true;
}
darkToggle.addEventListener('change', () => {
  document.body.classList.toggle('dark', darkToggle.checked);
  localStorage.setItem('dark', darkToggle.checked ? '1' : '0');
});

/* ============================================================
   SAVED BUILDS
============================================================ */

const loadSelect = $("loadBuildSelect");

function refreshBuilds() {
  loadSelect.innerHTML = '<option value="">– Load Build –</option>';
  const builds = JSON.parse(localStorage.getItem('atc') || '{}');
  const keys = Object.keys(builds).sort();

  if (keys.length === 0) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'No saved builds yet';
    opt.disabled = true;
    loadSelect.appendChild(opt);
    return;
  }

  keys.forEach(n => {
    const o = document.createElement('option');
    o.value = n;
    o.textContent = n;
    loadSelect.appendChild(o);
  });
}

function updateArrowWeightMode() {
  const simpleTotal = totalArrowWeightSimpleEl;
  const hint = $("totalWeightHint");
  const isAdv = toggleArrowEl.checked;

  if (isAdv) {
    simpleTotal.readOnly = true;
    simpleTotal.style.opacity = 0.6;
    hint.textContent = 'Total arrow weight is now calculated from components.';
  } else {
    simpleTotal.readOnly = false;
    simpleTotal.style.opacity = 1;
    hint.textContent = '';
  }
}

toggleStringEl.onchange = e => {
  $("stringAdvanced").style.display = e.target.checked ? 'block' : 'none';
  calculateEverything();
};

toggleArrowEl.onchange = e => {
  $("arrowAdvanced").style.display = e.target.checked ? 'block' : 'none';
  updateArrowWeightMode();
  calculateEverything();
};

$("saveBuild").onclick = () => {
  const n = $("buildName").value.trim();
  if (!n) return alert('Name required');
  const all = JSON.parse(localStorage.getItem('atc') || '{}');

  if (all[n] && !confirm(`Overwrite existing build "${n}"?`)) {
    return;
  }

  const data = {};
  document.querySelectorAll('input,select,textarea').forEach(el => {
    if (!el.id) return;
    if (el.type === 'checkbox') {
      data[el.id] = { type: 'checkbox', checked: el.checked };
    } else {
      data[el.id] = { type: 'value', value: el.value };
    }
  });

  all[n] = data;
  localStorage.setItem('atc', JSON.stringify(all));
  showToast('Build saved');
  refreshBuilds();
};

loadSelect.onchange = () => {
  const n = loadSelect.value;
  if (!n) return;
  const all = JSON.parse(localStorage.getItem('atc') || '{}');
  const d = all[n];
  if (!d) return;

  Object.keys(d).forEach(id => {
    const el = $(id);
    if (!el) return;

    const stored = d[id];

    if (stored && typeof stored === 'object' && 'type' in stored) {
      if (stored.type === 'checkbox') {
        el.checked = !!stored.checked;
        el.dispatchEvent(new Event('change'));
      } else {
        el.value = stored.value ?? '';
      }
    } else {
      if (el.type !== 'checkbox') {
        el.value = stored ?? '';
      }
    }
  });

  updateArrowWeightMode();
  calculateEverything();
  showToast('Build loaded');
};

$("deleteBuild").onclick = () => {
  let n = loadSelect.value;

  const typed = $("buildName").value.trim();
  if (!n && typed) n = typed;

  if (!n) {
    alert('Select a saved build or type its exact name to delete it.');
    return;
  }

  const all = JSON.parse(localStorage.getItem('atc') || '{}');

  if (!all[n]) {
    alert(`No saved build named "${n}" was found.`);
    return;
  }

  if (!confirm(`Delete build "${n}"?`)) return;

  delete all[n];
  localStorage.setItem('atc', JSON.stringify(all));
  refreshBuilds();
  loadSelect.value = '';
  showToast('Build deleted');
};

$("suggestName").onclick = () => {
  const d = new Date().toISOString().slice(0,10);
  const b = bowModelEl.value.trim() || 'Bow';
  const dw = drawWeightEl.value || '70';
  const arrow = arrowNameEl.value.trim() || 'Arrow';
  const weight = getArrowWeight().toFixed(0);
  const app = applicationEl.value || '';

  $("buildName").value =
    `${d} ${b} ${dw}lb ${arrow} ${weight}gr (${app})`;
};

/* ============================================================
   FPS SOURCE MARKERS
============================================================ */

const fpsInput = $("actualFPS");
const fpsSource = $("fpsSource");

function markFpsEstimated() {
  if (fpsSource) {
    fpsSource.textContent = 'Estimated from IBO & rules of thumb';
  }
  window.fpsSource = 'estimated';
}

function markFpsChrono() {
  if (fpsSource) {
    fpsSource.textContent = 'Manual (chrono) entry';
  }
  window.fpsSource = 'chrono';
}

/* ============================================================
   CORE MATH HELPERS
============================================================ */

function getArrowWeight() {
  const pointWeight = parseFloat(pointWeightEl.value) || 125;

  if (toggleArrowEl.checked) {
    const bare   = parseFloat(bareShaftEl.value)        || 0;
    const nock   = parseFloat(nockWeightEl.value)       || 0;
    const wrap   = parseFloat(wrapWeightEl.value)       || 0;
    const vanes  = (parseFloat(vaneWeightEachEl.value)  || 0) *
                   (parseFloat(vaneCountEl.value)       || 0);
    const insert = parseFloat(insertWeightEl.value)     || 0;
    const glue   = parseFloat(glueWeightEl.value)       || 0;

    const advTotal = bare + nock + wrap + vanes + insert + glue;
    $("arrowTotal").textContent = advTotal.toFixed(1);

    return advTotal + pointWeight;
  }

  return parseFloat(totalArrowWeightSimpleEl.value) || 0;
}

function getNumeric(id) {
  const el = $(id);
  if (!el) return NaN;

  const raw =
    el.tagName === 'INPUT'
      ? el.value
      : (el.textContent || el.innerText || '');

  const num = parseFloat(String(raw).replace(/[^\d.-]/g, ''));
  return Number.isFinite(num) ? num : NaN;
}

// Simple drop model for sight-based math
function computeDropInches(distanceYards, fps, zeroYards = 20) {
  if (!Number.isFinite(fps) || fps <= 0) return NaN;

  const gFt = 32.174;      // gravity in ft/s^2
  const v0  = fps;
  const RzFt = zeroYards * 3;

  let sin2theta = (RzFt * gFt) / (v0 * v0);
  if (sin2theta <= 0) return NaN;
  sin2theta = Math.min(1, Math.max(0, sin2theta));
  const theta = 0.5 * Math.asin(sin2theta);

  const cosTheta = Math.cos(theta);
  const sinTheta = Math.sin(theta);
  if (cosTheta <= 1e-6) return NaN;

  const dFt = distanceYards * 3;
  const t   = dFt / (v0 * cosTheta);

  const yFt = v0 * sinTheta * t - 0.5 * gFt * t * t;
  const dropIn = -yFt * 12;
  return dropIn;
}

// Simple drop model for sight-based math
function computeDropInches(distanceYards, fps, zeroYards = 20) {
  if (!Number.isFinite(fps) || fps <= 0) return NaN;

  const gFt = 32.174;      // gravity in ft/s^2
  const v0  = fps;
  const RzFt = zeroYards * 3;

  let sin2theta = (RzFt * gFt) / (v0 * v0);
  if (sin2theta <= 0) return NaN;
  sin2theta = Math.min(1, Math.max(0, sin2theta));
  const theta = 0.5 * Math.asin(sin2theta);

  const cosTheta = Math.cos(theta);
  const sinTheta = Math.sin(theta);
  if (cosTheta <= 1e-6) return NaN;

  const dFt = distanceYards * 3;
  const t   = dFt / (v0 * cosTheta);

  const yFt = v0 * sinTheta * t - 0.5 * gFt * t * t;
  const dropIn = -yFt * 12;
  return dropIn;
}

/**
 * Velocity decay length (L) in yards.
 * Heavier arrows (higher GPP) keep speed longer → larger L.
 * Lighter arrows (lower GPP) lose speed faster → smaller L.
 */
function getVelocityDecayYards(weightGrains, drawWeightLbs) {
  if (!Number.isFinite(weightGrains) || !Number.isFinite(drawWeightLbs) || drawWeightLbs <= 0) {
    return 300; // neutral fallback
  }

  const gpp = weightGrains / drawWeightLbs;   // grains-per-pound
  let delta = gpp - 7;                        // 7 GPP = neutral
  delta = clamp(delta, -2, 2);               // clamp between ~5–9 GPP

  const base = 300;      // neutral retention distance in yards
  const perGpp = 35;     // ~35 yd change in L per GPP step

  // 5 GPP → ~230 yd, 7 GPP → 300 yd, 9 GPP → ~370 yd
  return base + delta * perGpp;
}

/* ============================================================
   EASTON-STYLE SPINE RECOMMENDATION
   (stubbed example – expand with full chart as you like)
============================================================ */

/**
 * Convert raw draw weight + point weight into an "effective" bow weight,
 * similar in spirit to the Easton chart adjustments.
 *
 * - Heavier points make the arrow behave as if the bow is "heavier"
 *   → we bump the effective draw weight a bit.
 */
function getEffectiveBowWeight(drawWeightLbs, pointGrains) {
  if (!Number.isFinite(drawWeightLbs) || drawWeightLbs <= 0) return NaN;

  const base = drawWeightLbs;
  const refPoint = 100;        // many charts assume ~100 gr
  const extraPoint = Math.max(0, pointGrains - refPoint);

  // very rough: every +25 grains above 100 adds ~5 lb effective
  const extraLbs = (extraPoint / 25) * 5;

  return base + extraLbs;
}

/**
 * A minimal example of an Easton-style chart. You can extend this with
 * the full grid from the PDF.
 *
 * Each entry: a band of effective draw weight and arrow length,
 * mapping to a recommended spine range.
 */
const EASTON_SPINE_CHART = [
  // Light–medium draw, shorter arrows
  {
    minDw: 22, maxDw: 45,
    rows: [
      { maxLen: 26, minSpine: 600, maxSpine: 700 },
      { maxLen: 28, minSpine: 500, maxSpine: 600 },
      { maxLen: 30, minSpine: 400, maxSpine: 500 },
      { maxLen: 32, minSpine: 400, maxSpine: 500 }
    ]
  },
  // Mid-range hunting rigs
  {
    minDw: 46, maxDw: 65,
    rows: [
      { maxLen: 26, minSpine: 400, maxSpine: 500 },
      { maxLen: 28, minSpine: 350, maxSpine: 400 },
      { maxLen: 30, minSpine: 300, maxSpine: 350 },
      { maxLen: 32, minSpine: 300, maxSpine: 350 }
    ]
  },
  // Heavy draw weights
  {
    minDw: 66, maxDw: 90,
    rows: [
      { maxLen: 26, minSpine: 250, maxSpine: 300 },
      { maxLen: 28, minSpine: 250, maxSpine: 300 },
      { maxLen: 30, minSpine: 200, maxSpine: 250 },
      { maxLen: 32, minSpine: 200, maxSpine: 250 }
    ]
  }
];

/**
 * Look up recommended spine range based on:
 *  - effective bow weight (lbs)
 *  - shaft length (inches)
 *
 * Returns { minSpine, maxSpine, centerSpine } or null if not found.
 */
function lookupRecommendedSpine(effectiveDw, shaftLengthIn) {
  if (!Number.isFinite(effectiveDw) || !Number.isFinite(shaftLengthIn)) {
    return null;
  }

  for (const band of EASTON_SPINE_CHART) {
    if (effectiveDw < band.minDw || effectiveDw > band.maxDw) continue;

    // Find first row whose maxLen is >= shaft length
    let chosenRow = null;
    for (const row of band.rows) {
      if (shaftLengthIn <= row.maxLen) {
        chosenRow = row;
        break;
      }
    }

    // If no row matched length, use last row in band
    if (!chosenRow && band.rows.length > 0) {
      chosenRow = band.rows[band.rows.length - 1];
    }

    if (chosenRow) {
      const minSpine = chosenRow.minSpine;
      const maxSpine = chosenRow.maxSpine;
      const centerSpine = (minSpine + maxSpine) / 2;

      return { minSpine, maxSpine, centerSpine };
    }
  }

  return null;
}

/* ============================================================
   TARGET PANEL METRICS (Target / 3D / Other)
============================================================ */

function updateTargetPanelMetrics() {
  const mode = applicationEl.value;
  if (mode === 'Hunting') return; // only for Target / Other

  const fps = getNumeric('actualFPS');
  const foc = getNumeric('focValue');
  const gpi = getNumeric('gpiValue');

  // Group stability badge – use the same thresholds as the description
  if (groupStabilityBadgeEl) {
    if (Number.isFinite(fps) && Number.isFinite(foc) && Number.isFinite(gpi)) {
      const isTight =
        fps >= 270 &&      // solid speed
        foc >= 12 && foc <= 18 && // sweet-spot FOC band
        gpi <= 9.5;        // not overly heavy per inch

      groupStabilityBadgeEl.textContent = isTight ? 'Tight' : 'Average';
    } else {
      groupStabilityBadgeEl.textContent = '–';
    }
  }

  // Flatness score via extra drop from 20→60 yd
  if (flatnessScoreValueEl) {
    let label = '–';
    if (Number.isFinite(fps) && fps > 0) {
      const baseDrop20 = computeDropInches(20, fps);
      const drop60 = computeDropInches(60, fps);
      if (Number.isFinite(baseDrop20) && Number.isFinite(drop60)) {
        const extraDrop = drop60 - baseDrop20;
        const peakFt = Math.max(0, extraDrop / 12);

        if (peakFt < 3.0)      label = 'Very Flat';
        else if (peakFt < 4.5) label = 'Flat';
        else                   label = 'Curved';
      }
    }
    flatnessScoreValueEl.textContent = label;
  }

  // Drop table
  if (dropTableEl) {
    const distances = [20, 30, 40, 50, 60, 70];
    dropTableEl.innerHTML = '';

    distances.forEach(d => {
      const tr = document.createElement('tr');
      const tdDist = document.createElement('td');
      const tdDrop = document.createElement('td');

      tdDist.textContent = d.toString();

      if (!Number.isFinite(fps) || fps <= 0) {
        tdDrop.textContent = d === 20 ? '0.0' : '–';
      } else {
        let drop = computeDropInches(d, fps);
        if (!Number.isFinite(drop)) {
          tdDrop.textContent = d === 20 ? '0.0' : '–';
        } else {
          if (d === 20) drop = 0;
          tdDrop.textContent = drop.toFixed(1);
        }
      }

      tr.appendChild(tdDist);
      tr.appendChild(tdDrop);
      dropTableEl.appendChild(tr);
    });
  }
}

/* ============================================================
   APPLICATION MODE (Hunting vs Target)
============================================================ */

function updateApplicationPanels() {
  const mode = applicationEl.value;
  const huntingMode = (mode === 'Hunting');

  const huntingPanel = $("huntingMode");
  const targetPanel  = $("targetMode");
  const titleEl      = $("gameCardTitle");

  if (huntingPanel) {
    huntingPanel.style.display = huntingMode ? '' : 'none';
  }
  if (targetPanel) {
    targetPanel.style.display = huntingMode ? 'none' : '';
  }
  if (titleEl) {
    titleEl.textContent = huntingMode ? 'Game Effectiveness' : 'Target Insights';
  }

  if (!huntingMode) {
    updateTargetPanelMetrics();
  }
}

/* ============================================================
   MASTER CALCULATION
============================================================ */

function calculateEverything(recalcFPS = false) {
  const len = parseFloat(arrowLengthEl.value) || 28;
  const weight = getArrowWeight();
  const balance = parseFloat(balancePointEl.value) || 18.5;
  const ibo = parseFloat(iboEl.value) || 350;
  const dw = parseFloat(drawWeightEl.value) || 70;
  const drawLenVal = parseFloat(drawLengthEl.value) || 30;
  const point = parseFloat(pointWeightEl.value) || 125;
  const arrowSpine = parseFloat(arrowSpineEl.value) || NaN;

  const stringW = toggleStringEl.checked
    ? ['peepWeight','dloopWeight','kisserWeight','silencersWeight']
        .reduce((a,id)=>a+(parseFloat($(id).value)||0),0)
    : (parseFloat(stringSimpleEl.value) || 25);

  if (toggleStringEl.checked) {
    const total = ['peepWeight','dloopWeight','kisserWeight','silencersWeight']
      .reduce((a,id)=>a+(parseFloat($(id).value)||0),0);
    stringAdvTotalEl.textContent = total.toFixed(1);
  }

  let fps = parseFloat(fpsInput.value);
  if (recalcFPS || isNaN(fps) || fps <= 0) {
    // Rule-of-thumb IBO adjustments
    const refDW = 70;
    const refDL = 30;
    const refArrow = 350;

    const baseIbo = ibo || 300;
    const dwDelta = dw - refDW;
    const dlDelta = drawLenVal - refDL;
    const awDelta = weight - refArrow;
    const extraString = Math.max(0, stringW - 20);

    const adjFromDw      = dwDelta * 2;          // ~2 fps per pound
    const adjFromDl      = dlDelta * 10;         // ~10 fps per inch
    const adjFromWeight  = -(awDelta / 10) * 1.5;// ~1–2 fps per 10 gr above 350
    const adjFromString  = -(extraString / 10) * 1.5; // extra string mass penalty

    let estimated = baseIbo + adjFromDw + adjFromDl + adjFromWeight + adjFromString;

    // Soft real-world factor (gentle nudge down vs factory IBO)
    estimated *= 0.97;

    // Keep within a sane band
    estimated = Math.max(150, estimated);

    fps = estimated;
    fpsInput.value = fps.toFixed(1);
    markFpsEstimated();
  }

  // FOC
  const foc = ((balance - len/2) / len) * 100;

  focValueEl.textContent = foc.toFixed(1) + '%';

  const focClamped = Math.max(0, Math.min(30, isFinite(foc) ? foc : 0));
  const markerLeft = (focClamped / 30) * 100;
  if (focMarkerEl)  focMarkerEl.style.left  = markerLeft + '%';
  if (focBarFillEl) focBarFillEl.style.width = markerLeft + '%';

  if (!isFinite(foc)) {
    focHintEl.textContent = 'Enter arrow length, balance point, and weight to compute FOC.';
    focHintEl.style.color = 'var(--light)';
  } else if (foc >= 12 && foc <= 18) {
    focHintEl.textContent = 'Ideal range for many broadhead hunting setups.';
    focHintEl.style.color = 'var(--success)';
  } else if (foc < 10) {
    focHintEl.textContent = 'Very low FOC – may be less stable with broadheads.';
    focHintEl.style.color = 'var(--danger)';
  } else if (foc > 20) {
    focHintEl.textContent = 'Very high FOC – great penetration focus, but watch speed and tune.';
    focHintEl.style.color = 'var(--warning)';
  } else {
    focHintEl.textContent = 'Workable range; many setups run 10–20%.';
    focHintEl.style.color = 'var(--light)';
  }

  // GPP / GPI / TW
  const gpp = weight / dw;
  const gpi = weight / len;
  gppValueEl.textContent = gpp.toFixed(1);
  gpiValueEl.textContent = gpi.toFixed(1);
  twEl.textContent = weight.toFixed(1);

  const gppHint = $("gppHint");
  let gppText = '';
  let gppColor = 'var(--light)';
  if (gpp < 5) {
    gppText = 'Very light – often not recommended for most hunting bows.';
    gppColor = 'var(--danger)';
  } else if (gpp < 6) {
    gppText = 'Light arrow – flatter trajectory, more 3D/target style.';
  } else if (gpp <= 8) {
    gppText = 'Solid all-around hunting weight.';
    gppColor = 'var(--success)';
  } else {
    gppText = 'Heavy arrow – penetration-focused setups.';
  }
  if (gppHint) {
    gppHint.textContent = gppText;
    gppHint.style.color = gppColor;
  }

  // Launch KE / Momentum
  const launchKE = (weight * fps * fps) / 450240;
  const launchMom = (weight * fps) / 225400;
  keValueEl.textContent = launchKE.toFixed(1);

  // Distance & velocity @ distance
  const distYards = parseFloat(distanceSliderEl.value) || 50;
  $("distanceValue").textContent = distYards;

  // Velocity-at-distance model with GPP-aware decay length:
  // v(d) = v0 * e^(-d / L), where L depends on grains-per-pound
  const decayYards = getVelocityDecayYards(weight, dw);
  const currentV   = fps * Math.exp(-distYards / Math.max(decayYards, 1));

  // Impact KE & Momentum at that downrange velocity
  const impactKE  = (weight * currentV * currentV) / 450240;
  const impactMom = (weight * currentV) / 225400;

  // Time to impact:
  // distance in feet / average velocity between launch and downrange
  const distanceFt = distYards * 3;
  const avgV       = (fps + currentV) / 2;           // simple average of v₀ and v(d)
  const time       = distanceFt / Math.max(avgV, 1); // protect against divide-by-zero

  // Update UI tiles
  $("velocityDistanceLabel").textContent = distYards;
  velocityAtDistanceEl.textContent = currentV.toFixed(0);

  impactKEEl.textContent     = impactKE.toFixed(1);
  impactMomEl.textContent    = impactMom.toFixed(3);
  timeToImpactEl.textContent = time.toFixed(2);

  // Peak height (horizontal launch line model)
  const g = 32.174;
  const v0 = fps;
  const R_ft = distYards * 3;

  let peakHeightFt = 0;
  let peakYard = 0;
  if (v0 > 0 && R_ft > 0) {
    let sin2theta = (R_ft * g) / (v0 * v0);
    if (sin2theta > 0) {
      sin2theta = Math.min(1, Math.max(0, sin2theta));
      const theta = 0.5 * Math.asin(sin2theta);
      const sinTheta = Math.sin(theta);
      peakHeightFt = (v0 * v0 * sinTheta * sinTheta) / (2 * g);
      peakYard = distYards / 2;
    }
  }
  peakHeightValueEl.textContent = peakHeightFt.toFixed(1);
  peakDistanceValueEl.textContent = peakYard.toFixed(0);

  // Wind drift
  const windMph = parseFloat(windMphEl.value) || 0;
  const driftIn = 0.065 * (distYards * distYards) * windMph / Math.max(weight, 1);
  windDriftValueEl.textContent = driftIn.toFixed(1);

  // Composition bar
  const isAdv = toggleArrowEl.checked;
  let shaft = 0, pointW = 0, comp = 0;
  if (isAdv) {
    shaft = parseFloat(bareShaftEl.value) || 0;
    const nock   = parseFloat(nockWeightEl.value) || 0;
    const wrap   = parseFloat(wrapWeightEl.value) || 0;
    const vanes  = (parseFloat(vaneWeightEachEl.value) || 0) *
                   (parseFloat(vaneCountEl.value) || 0);
    const insert = parseFloat(insertWeightEl.value) || 0;
    const glue   = parseFloat(glueWeightEl.value) || 0;
    comp  = nock + wrap + vanes + insert + glue;
    pointW = point;
  } else {
    pointW = point;
    shaft = Math.max(0, weight - pointW);
    comp  = 0;
  }

  let shaftPct = 0, pointPct = 0, compPct = 0;
  if (weight > 0) {
    shaftPct = (shaft / weight) * 100;
    pointPct = (pointW / weight) * 100;
    compPct  = (comp  / weight) * 100;
  }

  const totalPct = shaftPct + pointPct + compPct;
  if (totalPct > 0 && Math.abs(totalPct - 100) > 0.5) {
    shaftPct = (shaftPct / totalPct) * 100;
    pointPct = (pointPct / totalPct) * 100;
    compPct  = (compPct  / totalPct) * 100;
  }

  if (compShaftSegEl) compShaftSegEl.style.width = shaftPct.toFixed(1) + '%';
  if (compPointSegEl) compPointSegEl.style.width = pointPct.toFixed(1) + '%';
  if (compOtherSegEl) compOtherSegEl.style.width = compPct.toFixed(1) + '%';

  if (compTotalLabelEl) compTotalLabelEl.textContent = weight > 0 ? `${weight.toFixed(1)} gr total` : '-';
  if (shaftPctLabelEl) shaftPctLabelEl.textContent = `Shaft: ${shaftPct.toFixed(0)}%`;
  if (pointPctLabelEl) pointPctLabelEl.textContent = `Point: ${pointPct.toFixed(0)}%`;
  if (compPctLabelEl)  compPctLabelEl.textContent  = `Comp.: ${compPct.toFixed(0)}%`;

  // Spine stiffness / forgiveness — Easton-style chart integration
  const spineBadge = stiffnessBadgeEl;
  const spineHint  = stiffnessHintEl;

  // Use draw weight + point weight to form an "effective" bow weight
  const effectiveDw = getEffectiveBowWeight(dw, point);

  // Update Effective Draw Weight display
  if (effDwEl) {
    effDwEl.textContent = Number.isFinite(effectiveDw)
      ? effectiveDw.toFixed(1)
      : '–';
  }

  // Look up recommended spine band from chart
  const rec = lookupRecommendedSpine(effectiveDw, len);
  const recMin = rec ? rec.minSpine : NaN;
  const recMax = rec ? rec.maxSpine : NaN;
  const recCenter = rec ? rec.centerSpine : NaN;

  if (
    spineBadge && spineHint &&
    Number.isFinite(arrowSpine) &&
    Number.isFinite(recCenter)
  ) {
    let label  = 'Good';
    let detail = '';

    if (arrowSpine < recMin) {
      // smaller number = stiffer
      label = 'Adjust';
      detail =
        `On the stiff side (arrow ${arrowSpine.toFixed(0)} vs ` +
        `chart band ~${recMin.toFixed(0)}–${recMax.toFixed(0)}). ` +
        `You can add point weight, lengthen the arrow slightly, or ` +
        `move to a weaker (higher-number) spine.`;
      spineBadge.style.color = 'var(--warning)';
    } else if (arrowSpine > recMax) {
      // larger number = weaker
      label = 'Adjust';
      detail =
        `On the weak side (arrow ${arrowSpine.toFixed(0)} vs ` +
        `chart band ~${recMin.toFixed(0)}–${recMax.toFixed(0)}). ` +
        `Consider shortening the arrow, reducing point weight, or ` +
        `moving to a stiffer (lower-number) shaft.`;
      spineBadge.style.color = 'var(--danger)';
    } else {
      // within recommended band
      label = 'Good';
      detail =
        `Arrow spine ≈ ${arrowSpine.toFixed(0)}, ` +
        `recommended chart band ≈ ${recMin.toFixed(0)}–${recMax.toFixed(0)}. ` +
        `Solid match to a typical Easton-style selection chart.`;
      spineBadge.style.color = 'var(--success)';
    }

    spineBadge.textContent = label;
    spineHint.textContent  = detail;
  } else if (spineBadge && spineHint) {
    spineBadge.textContent = '–';
    spineBadge.style.color = 'var(--light)';
    spineHint.textContent =
      'Enter draw weight, arrow length, point weight, and spine to check against a chart-style recommendation.';
  }

  // Game bands – conservative *minimum* thresholds (no upper cap)
  // KE mins are based on common Easton-style guidance:
  // 15–25 ft-lbs Small, 25–41 Medium (deer), 42–65 Large (elk),
  // 65–80 Toughest. Momentum mins are ballpark heuristics.
  const games = [
    {
      id: "smallGameStatus",
      label: "Small Game",
      keMin: 15,          // ft-lbs
      momMin: 0.20        // slug·ft/s
    },
    {
      id: "deerStatus",
      label: "Deer / Antelope",
      keMin: 25,
      momMin: 0.30
    },
    {
      id: "elkStatus",
      label: "Elk / Large Game",
      keMin: 42,
      momMin: 0.45
    },
    {
      id: "mooseStatus",
      label: "Toughest Game",
      keMin: 65,
      momMin: 0.60
    }
  ];

  games.forEach(gm => {
    const meetsKE  = impactKE  >= gm.keMin;
    const meetsMom = impactMom >= gm.momMin;

    gm.meetsKE  = meetsKE;
    gm.meetsMom = meetsMom;
    gm.ok       = meetsKE && meetsMom;

    const el = $(gm.id);
    if (!el) return;

    if (gm.ok) {
      // Overgunned or right on the line both show as "Send it"
      el.textContent = "Send it";
      el.style.color = "var(--success)";
    } else {
      el.textContent = "Adjust";
      el.style.color = "var(--warning)";
    }
  });

  // Build summary
  const summary = {
    "Build Name": $("buildName").value || "Unnamed",
    "Bow Model": bowModelEl.value || "-",
    "Draw Weight": dw + " lbs",
    "IBO Speed": ibo + " FPS",
    "Arrow Length": len.toFixed(2) + " in",
    "Total Arrow Weight": weight.toFixed(1) + " gr",
    "Point Weight": point.toFixed(0) + " gr",
    "Arrow Spine": Number.isFinite(arrowSpine) ? arrowSpine.toFixed(0) : "-",
    "FOC": foc.toFixed(1) + "%",
    "GPP": gpp.toFixed(1),
    "GPI": gpi.toFixed(1),
    "Launch FPS": fps.toFixed(1),
    "Launch KE": launchKE.toFixed(1) + " ft-lbs",
    "Launch Momentum": launchMom.toFixed(3) + " slug·ft/s",
    "Impact @ distance": `${distYards} yd`,
    "Impact Velocity": currentV.toFixed(0) + " FPS",
    "Impact KE": impactKE.toFixed(1) + " ft-lbs",
    "Impact Momentum": impactMom.toFixed(3) + " slug·ft/s",
    "Time to Impact": time.toFixed(2) + " s",
    "Wind Drift": driftIn.toFixed(1) + " in @ " + windMph.toFixed(0) + " mph"
  };

  summaryTableEl.innerHTML =
    '<table>' +
    Object.entries(summary).map(([k, v]) =>
      `<tr><td>${k}</td><td>${v}</td></tr>`
    ).join('') +
    '</table>';

  window.latestSummary = summary;

  // Recompute FPS estimate breakdown for math popup
  const refDW = 70;
  const refDL = 30;
  const refArrow = 350;
  const baseIbo = ibo || 300;
  const dwDelta = dw - refDW;
  const dlDelta = drawLenVal - refDL;
  const awDelta = weight - refArrow;
  const extraString = Math.max(0, stringW - 20);

  const adjFromDw      = dwDelta * 2;
  const adjFromDl      = dlDelta * 10;
  const adjFromWeight  = -(awDelta / 10) * 1.5;
  const adjFromString  = -(extraString / 10) * 1.5;

  let estimatedFps = baseIbo + adjFromDw + adjFromDl + adjFromWeight + adjFromString;
  estimatedFps *= 0.97;
  estimatedFps = Math.max(150, estimatedFps);

  window.math = {
    foc: { len, balance, mid: len / 2, value: foc },
    gpp: { weight, dw, value: gpp },
    gpi: { weight, len, value: gpi },
    tw:  { weight },
    fps: {
      ibo,
      stringW,
      weight,
      drawWeight: dw,
      drawLength: drawLenVal,
      refDrawWeight: refDW,
      refDrawLength: refDL,
      refArrowWeight: refArrow,
      baseFps: baseIbo,
      adjFromDrawWeight: adjFromDw,
      adjFromDrawLength: adjFromDl,
      adjFromArrowWeight: adjFromWeight,
      adjFromStringWeight: adjFromString,
      estimatedFps,
      usedFps: fps,
      source: window.fpsSource || 'estimated'
    },
    keLaunch: {
      weight,
      fps,
      value: launchKE
    },
    velocity: {
      launchFps: fps,
      distYards,
      decayYards,          // effective retention distance L (yards)
      gpp,                 // grains-per-pound snapshot
      value: currentV
    },
    peakHeight: {
      launchFps: fps,
      distYards,
      peakHeightFt,
      peakYard
    },
    impactKE: {
      weight,
      distYards,
      impactV: currentV,
      value: impactKE
    },
    impactMom: {
      weight,
      distYards,
      impactV: currentV,
      value: impactMom
    },
    timeToImpact: {
      distYards,
      distFeet: distanceFt,  // distance converted to feet
      value: time,           // final time in seconds
      launchFps: fps,        // launch velocity
      impactV: currentV,     // velocity at distance
      avgV                    // average velocity between launch & impact
    },
    wind: {
      distYards,
      windMph,
      weight,
      value: driftIn
    },
    game: {
      distYards,
      impactKE,
      impactMom,
      bands: games
    },
    awc: {
      weight,
      shaft,
      point: pointW,
      comp,
      shaftPct,
      pointPct,
      compPct
    },
    spine: {
      drawWeight: dw,
      arrowLength: len,
      pointWeight: point,
      effectiveDrawWeight: effectiveDw,
      recommendedBandMin: recMin,
      recommendedBandMax: recMax,
      recommendedCenter: recCenter,
      arrowSpine,
      totalArrowWeight: weight
    }
  };

  updateApplicationPanels();
}

/* ============================================================
   BUTTONS & INPUT LISTENERS
============================================================ */

$("recalcFPS").onclick = () => calculateEverything(true);

copySummaryBtn.onclick = () => {
  if (!window.latestSummary) {
    calculateEverything(false);
  }
  const summary = window.latestSummary || {};
  const lines = [
    `Arrow Tune Build - ${new Date().toLocaleDateString()}`,
    ''
  ];

  Object.entries(summary).forEach(([k, v]) => {
    if (v === '') return;
    lines.push(`${k}: ${v}`);
  });

  const text = lines.join('\n');
  navigator.clipboard.writeText(text).then(() => showToast('Summary copied'));
};

distanceSliderEl.oninput = e => {
  $("distanceValue").textContent = e.target.value;
  calculateEverything();
};

// Let the user edit the distance (yd) by clicking the printed value
const distanceDisplayEl = $("distanceValue");

function setDistanceFromInput(rawVal) {
  let d = parseFloat(rawVal);
  if (!Number.isFinite(d)) return;

  const min = parseFloat(distanceSliderEl.min || "10");
  const max = parseFloat(distanceSliderEl.max || "100");
  d = clamp(d, min, max);

  distanceSliderEl.value = d;
  distanceDisplayEl.textContent = d.toFixed(0);
  calculateEverything();
}

if (distanceDisplayEl) {
  // Make it tabbable for keyboard users
  distanceDisplayEl.setAttribute("tabindex", "0");

  distanceDisplayEl.addEventListener("click", () => {
    const current = distanceSliderEl.value || "50";

    // Create a temporary number input inside the label
    const input = document.createElement("input");
    input.type = "number";
    input.value = current;
    input.min = distanceSliderEl.min || "10";
    input.max = distanceSliderEl.max || "100";
    input.step = distanceSliderEl.step || "1";
    input.style.width = "4rem";
    input.style.textAlign = "center";
    input.style.background = "transparent";
    input.style.border = "1px solid var(--border)";
    input.style.borderRadius = "4px";
    input.style.color = "inherit";
    input.style.font = "inherit";

    distanceDisplayEl.textContent = "";
    distanceDisplayEl.appendChild(input);
    input.focus();
    input.select();

    function commit() {
      setDistanceFromInput(input.value);
    }

    function cancel() {
      distanceDisplayEl.textContent = current;
    }

    input.addEventListener("blur", commit);

    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        commit();
      } else if (e.key === "Escape") {
        cancel();
        input.blur();
      }
    });
  });

  // Optional: allow Enter from keyboard focus (without mouse click)
  distanceDisplayEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      distanceDisplayEl.click();
    }
  });
}



document.querySelectorAll('input,select,textarea').forEach(el => {
  el.addEventListener('input', () => {
    if (document.activeElement.id === 'actualFPS') {
      markFpsChrono();
      calculateEverything(false);
    } else {
      calculateEverything();
    }
  });
});

/* ============================================================
   INFO + MATH OVERLAYS
============================================================ */

function openInfo(key) {
  if (!infoOverlay || !infoBody) return;

  infoBody.innerHTML = INFO_CONTENT[key] || `
    <h2>Info</h2>
    <p>More details coming soon.</p>
  `;

  infoOverlay.classList.add('open');
}

function openMath(key) {
  if (!infoOverlay || !infoBody) return;
  if (!window.math) {
    calculateEverything(false);
  }
  const m = window.math || {};
  let html = '';

  if (key === 'foc' && m.foc) {
    const f = m.foc;
    html = `
      <h2>FOC Math</h2>
      <p><strong>Formula:</strong> FOC = ((Balance Point − (Arrow Length ÷ 2)) ÷ Arrow Length) × 100</p>
      <p>Arrow Length = ${f.len.toFixed(2)} in</p>
      <p>Midpoint = ${f.mid.toFixed(2)} in</p>
      <p>Balance Point = ${f.balance.toFixed(2)} in</p>
      <p>FOC = ((${f.balance.toFixed(2)} − ${f.mid.toFixed(2)}) ÷ ${f.len.toFixed(2)}) × 100
         = <strong>${f.value.toFixed(1)}%</strong></p>
    `;
  } else if (key === 'gpp' && m.gpp) {
    const g = m.gpp;
    html = `
      <h2>GPP Math</h2>
      <p><strong>Formula:</strong> GPP = Total Arrow Weight ÷ Draw Weight</p>
      <p>Total Arrow Weight = ${g.weight.toFixed(1)} gr</p>
      <p>Draw Weight = ${g.dw.toFixed(1)} lb</p>
      <p>GPP = ${g.weight.toFixed(1)} ÷ ${g.dw.toFixed(1)} = <strong>${g.value.toFixed(1)}</strong></p>
    `;
  } else if (key === 'gpi' && m.gpi) {
    const g = m.gpi;
    html = `
      <h2>GPI Math</h2>
      <p><strong>Formula:</strong> GPI = Total Arrow Weight ÷ Arrow Length</p>
      <p>Total Arrow Weight = ${g.weight.toFixed(1)} gr</p>
      <p>Arrow Length = ${g.len.toFixed(2)} in</p>
      <p>GPI = ${g.weight.toFixed(1)} ÷ ${g.len.toFixed(2)} = <strong>${g.value.toFixed(1)}</strong></p>
    `;
  } else if (key === 'tw' && m.tw) {
    const t = m.tw;
    html = `
      <h2>Total Arrow Weight</h2>
      <p>This is the finished arrow weight used for all other calculations.</p>
      <p>Total Arrow Weight = <strong>${t.weight.toFixed(1)} grains</strong></p>
    `;
  } else if (key === 'fps' && m.fps) {
    const f = m.fps;
    html = `
      <h2>FPS Estimate Math</h2>
      <p>
        When you don’t have a chronograph reading, the app uses a 
        <strong>rule-of-thumb estimate</strong> based on your bow’s IBO rating:
      </p>
      <ul style="margin-left:1.25rem;">
        <li>Start from IBO (often 30&quot;/70 lb/350 gr arrow).</li>
        <li>Adjust a few FPS per pound above or below 70 lb.</li>
        <li>Adjust roughly 8–12 FPS per inch above or below 30&quot; draw.</li>
        <li>Trim 1–2 FPS per extra ~5–10 grains above 350 gr arrow weight.</li>
        <li>Subtract a few FPS for peep, D-loop, silencers, and other string add-ons.</li>
      </ul>
      <p><strong>Your inputs:</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>IBO / ATA rating: ${f.ibo.toFixed(0)} FPS (base)</li>
        <li>Draw weight: ${f.drawWeight.toFixed(1)} lb (ref ~${f.refDrawWeight} lb)</li>
        <li>Draw length: ${f.drawLength.toFixed(2)} in (ref ~${f.refDrawLength} in)</li>
        <li>Arrow weight: ${f.weight.toFixed(1)} gr (ref ~${f.refArrowWeight} gr)</li>
        <li>String add-ons: ${f.stringW.toFixed(1)} gr (first ~20 gr assumed “free”)</li>
      </ul>
      <p><strong>Approximate breakdown:</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>Base IBO: ${f.baseFps.toFixed(1)} FPS</li>
        <li>Draw weight adjustment: ${f.adjFromDrawWeight.toFixed(1)} FPS</li>
        <li>Draw length adjustment: ${f.adjFromDrawLength.toFixed(1)} FPS</li>
        <li>Arrow weight adjustment: ${f.adjFromArrowWeight.toFixed(1)} FPS</li>
        <li>String add-ons adjustment: ${f.adjFromStringWeight.toFixed(1)} FPS</li>
      </ul>
      <p>
        After a small real-world correction, the estimate lands at 
        <strong>${f.estimatedFps.toFixed(1)} FPS</strong>.
      </p>
      <p>
        FPS used in calculations: <strong>${f.usedFps.toFixed(1)} FPS</strong>
        (${f.source === 'chrono' ? 'manual (chrono) entry' : 'estimated from IBO & rules of thumb'}).
      </p>
      <p>
        Always treat this as a <strong>ballpark</strong> until you can confirm with an actual chronograph.
      </p>
    `;
  } else if (key === 'keLaunch' && m.keLaunch) {
    const k = m.keLaunch;
    html = `
      <h2>Launch Kinetic Energy</h2>
      <p>
        Kinetic energy (KE) is a measure of how much <strong>work</strong> your arrow can do on impact.
        It depends on both arrow <strong>mass</strong> and <strong>speed</strong>, and is one of the
        classic ways bowhunters compare setups.
      </p>
      <p><strong>Formula (archery units):</strong></p>
      <p>
        KE (ft-lbs) = (Arrow Weight (grains) × Velocity (fps)²) ÷ 450240
      </p>
      <p>
        The constant <strong>450240</strong> packs in all the unit conversions to go from
        grains and feet-per-second to foot-pounds of energy:
      </p>
      <ul style="margin-left:1.25rem;">
        <li>7000 grains = 1 pound of mass</li>
        <li>g ≈ 32.174 ft/s² (acceleration due to gravity)</li>
        <li>KE = ½ × m × v², with m in slugs → all rolled into 450240</li>
      </ul>
      <p><strong>Your numbers at launch:</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>Arrow Weight = <strong>${k.weight.toFixed(1)} gr</strong></li>
        <li>Launch Velocity = <strong>${k.fps.toFixed(1)} fps</strong></li>
      </ul>
      <p>Step-by-step:</p>
      <p>
        KE = (${k.weight.toFixed(1)} × ${k.fps.toFixed(1)}²) ÷ 450240
      </p>
      <p>
        KE ≈ <strong>${k.value.toFixed(1)} ft-lbs</strong> at the bow.
      </p>
      <p style="margin-top:0.5rem;">
        Downrange, the calculator repeats this same formula using your
        <strong>estimated velocity at distance</strong> to show how much energy is left
        at the target for the Game Effectiveness panel.
      </p>
    `;
  } else if (key === 'velocity' && m.velocity) {
    const v = m.velocity;
    const L = Number.isFinite(v.decayYards) && v.decayYards > 0 ? v.decayYards : 300;
    const exponent = -v.distYards / L;

    html = `
      <h2>Velocity at Distance</h2>
      <p><strong>Model:</strong> v(d) = v₀ × e^(−d / L)</p>
      <p>
        v₀ is your launch FPS, d is distance in yards, and L is an
        effective “speed-retention distance” in yards.
      </p>
      <p><strong>Your inputs:</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>Launch velocity v₀ = ${v.launchFps.toFixed(1)} FPS</li>
        <li>Distance d = ${v.distYards.toFixed(0)} yd</li>
        <li>Current GPP ≈ ${Number.isFinite(v.gpp) ? v.gpp.toFixed(2) : '–'} gr/lb</li>
        <li>Retention distance L ≈ ${L.toFixed(0)} yd</li>
      </ul>
      <p><strong>Computation:</strong></p>
      <p>
        v(d) = ${v.launchFps.toFixed(1)} × e<sup>${exponent.toFixed(3)}</sup>
        ≈ <strong>${v.value.toFixed(0)} FPS</strong>
      </p>
      <p style="margin-top:0.5rem;">
        Lower GPP arrows get a smaller L (they slow down faster); higher GPP
        arrows get a larger L (they keep speed longer). This keeps the curve
        in the ballpark of real hunting rigs without trying to be a full
        drag-coefficient ballistic solver.
      </p>
    `;
  } else if (key === 'peakHeight' && m.peakHeight) {
    const p = m.peakHeight;
    const g = 32.174;                 // ft/s², gravity
    const v0 = p.launchFps;           // launch speed in FPS
    const Ryd = p.distYards;          // target distance in yards
    const Rft = Ryd * 3;              // convert yards → feet

    // Same steps the calculator uses in calculateEverything(...)
    const v0sq = v0 * v0;
    let sin2theta = (Rft * g) / v0sq;
    // Clamp to a safe 0–1 range for asin
    sin2theta = Math.min(1, Math.max(0, sin2theta));
    const thetaRad = 0.5 * Math.asin(sin2theta);
    const thetaDeg = thetaRad * 180 / Math.PI;
    const sinTheta = Math.sin(thetaRad);

    const peakFt   = p.peakHeightFt;  // already computed in main math
    const peakYd   = p.peakYard;      // typically ~Ryd / 2

    html = `
      <h2>Peak Height Math</h2>

      <p>
        Peak Height uses a simple <strong>projectile model</strong> on level ground to
        estimate how high the arrow climbs above a <strong>horizontal launch line</strong>
        before gravity pulls it back down.
      </p>

      <p><strong>1) Inputs and unit conversions</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>Launch speed v₀ = <strong>${v0.toFixed(1)} fps</strong></li>
        <li>Target distance R = <strong>${Ryd.toFixed(0)} yd</strong>
            → R = ${Ryd.toFixed(0)} × 3 = <strong>${Rft.toFixed(1)} ft</strong></li>
        <li>Gravity g ≈ <strong>${g.toFixed(3)} ft/s²</strong></li>
      </ul>

      <p><strong>2) Solve for launch angle</strong></p>
      <p>
        For a level shot (same height bow to target), the classic range equation is:
      </p>
      <p style="margin-left:1.25rem;">
        R = (v₀² / g) × sin(2θ)
      </p>
      <p>
        Rearranged to find the angle θ:
      </p>
      <p style="margin-left:1.25rem;">
        sin(2θ) = (R × g) / v₀²
      </p>
      <p>With your numbers:</p>
      <p style="margin-left:1.25rem;">
        sin(2θ) = (${Rft.toFixed(1)} × ${g.toFixed(3)}) ÷ ${v0sq.toFixed(1)}
        ≈ <strong>${sin2theta.toFixed(3)}</strong>
      </p>
      <p>
        Then:
      </p>
      <p style="margin-left:1.25rem;">
        2θ = arcsin(${sin2theta.toFixed(3)}) → θ ≈ <strong>${thetaDeg.toFixed(1)}°</strong>
      </p>

      <p><strong>3) Compute peak height above the launch line</strong></p>
      <p>
        For a projectile launched at angle θ, the maximum height above the
        <em>horizontal launch line</em> is:
      </p>
      <p style="margin-left:1.25rem;">
        H<sub>max</sub> = (v₀² × sin²θ) ÷ (2g)
      </p>
      <p>
        Plugging in your values:
      </p>
      <p style="margin-left:1.25rem;">
        H<sub>max</sub> ≈ <strong>${peakFt.toFixed(2)} ft</strong>
        (shown as ${peakFt.toFixed(1)} ft in the tile)
      </p>

      <p><strong>4) Where along the path does this happen?</strong></p>
      <p>
        For this idealized arc, the apex occurs halfway through the flight in
        horizontal distance:
      </p>
      <p style="margin-left:1.25rem;">
        Distance to peak ≈ R ÷ 2 ≈ ${ (Ryd / 2).toFixed(1) } yd
      </p>
      <p>
        The calculator reports this as:
        <strong>${peakYd.toFixed(0)} yd</strong>.
      </p>

      <p style="margin-top:0.75rem;">
        Remember: this height is measured from a
        <strong>flat launch line</strong>, not from your tilted peep–to–pin line. That’s
        why Peak Height won’t match your sight–tape “drop” numbers one-for-one, but it
        does give a clear picture of <em>how tall</em> the true arc is and whether it
        will comfortably clear obstacles between you and the target.
      </p>
    `;
  } else if (key === 'impactKE' && m.impactKE) {
    const k = m.impactKE;
    html = `
      <h2>Impact Kinetic Energy</h2>
      <p>
        Kinetic energy (KE) is how much <strong>work</strong> your arrow can do on
        impact. It depends on both <strong>mass</strong> and <strong>speed</strong>,
        and it naturally drops as the arrow slows down downrange.
      </p>

      <p><strong>Archery formula:</strong></p>
      <p>
        KE (ft-lbs) = (Arrow Weight (grains) × Velocity (fps)²) ÷ 450240
      </p>

      <p>
        The constant <strong>450240</strong> bundles the unit conversions needed to go
        from grains and feet-per-second into foot-pounds:
      </p>
      <ul style="margin-left:1.25rem;">
        <li>7000 grains = 1 pound of mass</li>
        <li>g ≈ 32.174 ft/s² (acceleration due to gravity)</li>
        <li>KE = ½ × m × v² in consistent units (slugs and ft/s)</li>
      </ul>
      <p>
        Bowhunters have used this compact version for decades; you just plug in grains
        and FPS and get ft-lbs directly.
      </p>

      <p><strong>Your numbers at the target:</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>Arrow Weight = <strong>${k.weight.toFixed(1)} gr</strong></li>
        <li>Impact Velocity at ${k.distYards.toFixed(0)} yd = 
            <strong>${k.impactV.toFixed(1)} FPS</strong></li>
      </ul>

      <p>Step-by-step at this distance:</p>
      <p>
        KE = (${k.weight.toFixed(1)} × ${k.impactV.toFixed(1)}²) ÷ 450240
      </p>
      <p>
        KE ≈ <strong>${k.value.toFixed(1)} ft-lbs</strong> at 
        <strong>${k.distYards.toFixed(0)} yards</strong>.
      </p>

      <p style="margin-top:0.5rem;">
        You can compare this number to the <strong>Launch KE</strong> to see how much
        energy you keep out to that yardage, and to the <strong>Game Effectiveness</strong>
        bands to decide whether to <em>send it</em> or adjust arrow weight, distance,
        or shot selection.
      </p>
    `;
  } else if (key === 'impactMom' && m.impactMom) {
    const mom = m.impactMom;
    const W = mom.weight.toFixed(1);
    const V = mom.impactV.toFixed(1);

    html = `
      <h2>Impact Momentum</h2>

      <p>
        Momentum is a measure of how hard an arrow keeps pushing after impact.
        Unlike KE (which scales with velocity squared), momentum scales
        <strong>linearly</strong> with both mass and velocity, so heavier arrows
        tend to hold their penetration better at long range.
      </p>

      <p><strong>Archery formula:</strong></p>
      <p>
        Momentum (slug·ft/s) = (Arrow Weight (grains) × Velocity (fps)) ÷ 225400
      </p>

      <p><strong>Your values at the target:</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>Arrow Weight = ${W} grains</li>
        <li>Impact Velocity at ${mom.distYards.toFixed(0)} yd = ${V} FPS</li>
      </ul>

      <p><strong>Where 225400 comes from:</strong></p>
      <p>
        It bundles the unit conversions from grains and feet-per-second into
        slug·ft/s:
      </p>
      <ul style="margin-left:1.25rem;">
        <li>7000 grains = 1 pound of mass</li>
        <li>1 slug = 32.174 lb·s²/ft</li>
        <li>Momentum = mass × velocity in consistent units</li>
      </ul>

      <p><strong>Step-by-step at this distance:</strong></p>
      <p>
        Momentum = (${W} × ${V}) ÷ 225400
      </p>
      <p>
        Momentum ≈ <strong>${mom.value.toFixed(3)} slug·ft/s</strong>
        at <strong>${mom.distYards.toFixed(0)} yards</strong>.
      </p>

      <p style="margin-top:0.75rem;">
        In the Game Effectiveness panel, this is paired with impact KE to give a more
        complete picture of how your arrow will behave on real animals.
      </p>
    `;
  } else if (key === 'timeToImpact' && m.timeToImpact) {
    const t = m.timeToImpact;
    html = `
      <h2>Time to Impact</h2>
      <p>
        The calculator uses a simple <strong>average–velocity model</strong> so the
        math stays intuitive but still reacts correctly when you change FPS, arrow
        weight, or distance.
      </p>

      <p><strong>1) Convert distance to feet</strong></p>
      <p>
        d<sub>ft</sub> = d<sub>yd</sub> × 3<br>
        d<sub>yd</sub> = ${t.distYards.toFixed(0)} yd → 
        d<sub>ft</sub> = ${t.distYards.toFixed(0)} × 3
        = <strong>${t.distFeet.toFixed(1)} ft</strong>
      </p>

      <p><strong>2) Estimate average velocity</strong></p>
      <p>
        We assume the arrow slows down roughly in a straight line from launch
        speed to the estimated speed at your chosen distance, then take the
        average of those two speeds:
      </p>
      <p>
        v₀ (launch speed) = ${t.launchFps.toFixed(1)} fps<br>
        v(d) (speed at ${t.distYards.toFixed(0)} yd) ≈ ${t.impactV.toFixed(1)} fps<br>
        v̄ (average speed) = (v₀ + v(d)) ÷ 2
      </p>
      <p>
        v̄ = (${t.launchFps.toFixed(1)} + ${t.impactV.toFixed(1)}) ÷ 2
        ≈ <strong>${t.avgV.toFixed(1)} fps</strong>
      </p>

      <p><strong>3) Time = distance ÷ average speed</strong></p>
      <p>
        t = d<sub>ft</sub> ÷ v̄
      </p>
      <p>
        t = ${t.distFeet.toFixed(1)} ÷ ${t.avgV.toFixed(1)}
        ≈ <strong>${t.value.toFixed(2)} s</strong>
      </p>

      <p style="margin-top:0.5rem;">
        This isn’t trying to be a full-blown physics sim — it’s a
        <strong>ballpark flight time</strong> that tracks correctly with your FPS,
        arrow mass, and distance so you can think about string jump and animal
        movement in realistic terms.
      </p>
    `;
  } else if ((key === 'wind' || key === 'windDrift') && m.wind) {
    const w = m.wind;
    html = `
      <h2>Wind Drift Math</h2>

      <p>
        This drift model is a <strong>practical archery approximation</strong> — not a CFD solver —
        designed to match typical hunting-weight arrows in 5–20 mph winds.
        It shows how distance, wind speed, and arrow weight interact.
      </p>

      <p><strong>1) Inputs</strong></p>
      <ul style="margin-left:1.25rem;">
        <li>Distance = <strong>${w.distYards.toFixed(0)} yd</strong></li>
        <li>Wind speed = <strong>${w.windMph.toFixed(0)} mph</strong></li>
        <li>Arrow weight = <strong>${w.weight.toFixed(1)} gr</strong></li>
      </ul>

      <p><strong>2) Approximate formula</strong></p>
      <p>
        drift ≈ 0.065 × distance² × wind ÷ arrowWeight
      </p>
      <p>
        The constant <strong>0.065</strong> is tuned to typical arrow aerodynamics:
        heavier arrows drift less, lighter arrows drift more, and drift increases rapidly with distance.
      </p>

      <p><strong>3) Plug in your numbers</strong></p>
      <p style="margin-left:1.25rem;">
        drift ≈ 0.065 × ${w.distYards.toFixed(0)}² × ${w.windMph.toFixed(0)} ÷ ${w.weight.toFixed(1)}
      </p>

      <p><strong>4) Result</strong></p>
      <p>
        Wind drift ≈ <strong>${w.value.toFixed(1)} inches</strong>
      </p>

      <p style="margin-top:0.5rem;">
        Heavier shafts, higher FOC, and smaller fletchings generally reduce drift.
        A 10–15 mph crosswind at 40–60 yards is where differences between light and heavy arrows become most noticeable.
      </p>
    `;
  } else if (key === 'game' && m.game) {
    const g = m.game;
    const rows = (g.bands || []).map(b => {
      const status    = b.ok ? 'Send it' : 'Adjust';
      const keStatus  = g.impactKE  >= b.keMin  ? '✓' : '×';
      const momStatus = g.impactMom >= b.momMin ? '✓' : '×';

      return `
        <tr>
          <td>${b.label}</td>
          <td>${b.keMin.toFixed(0)}+</td>
          <td>${b.momMin.toFixed(2)}+</td>
          <td>${g.impactKE.toFixed(1)} (${keStatus})</td>
          <td>${g.impactMom.toFixed(3)} (${momStatus})</td>
          <td>${status}</td>
        </tr>
      `;
    }).join('');

    html = `
      <h2>Game Effectiveness Math</h2>
      <p>At ${g.distYards.toFixed(0)} yd this build is carrying:</p>
      <ul style="margin-left:1.25rem;">
        <li>Impact KE = <strong>${g.impactKE.toFixed(1)} ft-lbs</strong></li>
        <li>Impact Momentum = <strong>${g.impactMom.toFixed(3)} slug·ft/s</strong></li>
      </ul>
      <p>
        Each band below is a <strong>minimum</strong> guideline: being “overgunned”
        (well above the line) still shows as <strong>Send it</strong>. 
      </p>
      <div style="overflow-x:auto;margin-top:0.5rem;">
        <table style="font-size:0.9rem;margin-top:0;">
          <thead>
            <tr>
              <th>Class</th>
              <th>KE Min (ft-lbs)</th>
              <th>Mom Min (slug·ft/s)</th>
              <th>Your KE</th>
              <th>Your Mom</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      </div>
      <p style="margin-top:0.5rem;">
        These are <em>conservative</em> sanity checks, not guarantees. Broadhead design, 
        arrow flight, and shot placement still matter more than any single number.
      </p>  
    `;
  } else if (key === 'awc' && m.awc) {
    const a = m.awc;
    html = `
      <h2>Arrow Weight Composition Math</h2>
      <p>Total Arrow Weight = <strong>${a.weight.toFixed(1)} gr</strong></p>
      <p>Breakdown:</p>
      <ul>
        <li><strong>Shaft:</strong> ${a.shaft.toFixed(1)} gr (${a.shaftPct.toFixed(0)}%)</li>
        <li><strong>Point:</strong> ${a.point.toFixed(1)} gr (${a.pointPct.toFixed(0)}%)</li>
        <li><strong>Components:</strong> ${a.comp.toFixed(1)} gr (${a.compPct.toFixed(0)}%)</li>
      </ul>
    `;
  } else if (key === 'sightMarks') {
    const fps = getNumeric('actualFPS');
    if (!Number.isFinite(fps) || fps <= 0) {
      html = `
        <h2>Downrange Arrow Drop Math</h2>
        <p>Enter a valid launch FPS to compute relative drop from a 20 yd zero.</p>
      `;
    } else {
      const distances = [20, 30, 40, 50, 60, 70];
      const base20 = computeDropInches(20, fps);
      const rows = distances.map(d => {
        const drop = computeDropInches(d, fps);
        let rel = drop - base20;
        if (d === 20) rel = 0;
        const relStr = Number.isFinite(rel) ? rel.toFixed(1) : '–';
        return `<tr><td>${d}</td><td>${relStr}</td></tr>`;
      }).join('');

      html = `
        <h2>Downrange Arrow Drop Math</h2>
        <p>
          We estimate gravity drop at each distance, then subtract the 20 yd value
          so 20 yd is always 0.0 in.
        </p>
        <div style="overflow-x:auto;margin-top:0.5rem;">
          <table style="font-size:0.9rem;margin-top:0;">
            <thead>
              <tr>
                <th>Distance (yd)</th>
                <th>Drop vs 20 yd (in)</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    }
  } else if (key === 'groupStability') {
    const fps = getNumeric('actualFPS');
    const foc = getNumeric('focValue');
    const gpi = getNumeric('gpiValue');

    if (!Number.isFinite(fps) || !Number.isFinite(foc) || !Number.isFinite(gpi)) {
      html = `
        <h2>Group Stability Math</h2>
        <p>
          Enter launch FPS, FOC, and arrow length/weight so the app can estimate
          group stability.
        </p>
      `;
    } else {
      const isTight =
        fps >= 270 &&
        foc >= 12 && foc <= 18 &&
        gpi <= 9.5;

      const label = isTight ? 'Tight' : 'Average';

      html = `
        <h2>Group Stability Math</h2>
        <p>Current values:</p>
        <ul style="margin-left:1.25rem;">
          <li>FPS = <strong>${fps.toFixed(1)}</strong></li>
          <li>FOC = <strong>${foc.toFixed(1)}%</strong></li>
          <li>GPI = <strong>${gpi.toFixed(1)}</strong></li>
        </ul>
        <p>Badge result: <strong>${label}</strong>.</p>
        <p>
          The calculator flags <strong>Tight</strong> when all of these are true:
        </p>
        <ul style="margin-left:1.25rem;">
          <li>Launch FPS ≳ <strong>270</strong></li>
          <li>FOC between <strong>12–18%</strong></li>
          <li>GPI ≲ <strong>9.5 gr/in</strong></li>
        </ul>
        <p>
          Anything outside that zone is labeled <strong>Average</strong> — still fully
          usable, but not as optimized on paper for forgiveness and small groups.
        </p>
      `;
    }

  } else if (key === 'stiffness' && m.spine) {
    const s = m.spine || {};

    const hasDW     = Number.isFinite(s.drawWeight);
    const hasLen    = Number.isFinite(s.arrowLength);
    const hasPT     = Number.isFinite(s.pointWeight);
    const hasEff    = Number.isFinite(s.effectiveDrawWeight);
    const hasCenter = Number.isFinite(s.recommendedCenter);
    const hasMin    = Number.isFinite(s.recommendedBandMin);
    const hasMax    = Number.isFinite(s.recommendedBandMax);
    const hasShaft  = Number.isFinite(s.arrowSpine);

    // If we don't have enough numeric data, keep the simple explanation
    if (!hasDW || !hasLen || !hasPT || !hasEff || !hasCenter || !hasShaft) {
      html = `
        <h2>Stiffness / Forgiveness Math</h2>
        <p>
          This badge compares your actual arrow spine (the number printed on the shaft)
          to a chart-style recommendation based on draw weight, arrow length,
          and point weight.
        </p>
        <p>To see the full numeric breakdown, make sure you’ve entered:</p>
        <ul style="margin-left:1.25rem;">
          <li><strong>Draw Weight</strong> (lbs)</li>
          <li><strong>Arrow Length</strong> (inches)</li>
          <li><strong>Point Weight</strong> (grains)</li>
          <li><strong>Arrow Spine</strong> (e.g., 250 / 300 / 340 / 400)</li>
        </ul>
        <p>
          Once those are filled in, the calculator estimates a recommended spine band
          and shows how far your current shaft is from that “chart” value.
        </p>
      `;
    } else {
      const DW   = s.drawWeight;
      const L    = s.arrowLength;
      const PT   = s.pointWeight;
      const W    = Number.isFinite(s.totalArrowWeight) ? s.totalArrowWeight : NaN;
      const eff  = s.effectiveDrawWeight;
      const ctr  = s.recommendedCenter;
      const bandMin = hasMin ? s.recommendedBandMin : ctr;
      const bandMax = hasMax ? s.recommendedBandMax : ctr;
      const shaft   = s.arrowSpine;

      const delta = shaft - ctr;

      let sideSummary;
      if (shaft >= bandMin && shaft <= bandMax) {
        sideSummary = 'inside the recommended band — a very chart-correct match.';
      } else if (shaft < bandMin) {
        sideSummary = 'on the <strong>stiffer</strong> side of the chart (lower spine number than recommended).';
      } else {
        sideSummary = 'on the <strong>weaker</strong> side of the chart (higher spine number than recommended).';
      }

      html = `
        <h2>Stiffness / Forgiveness Math</h2>

        <p>
          This badge compares your <strong>actual arrow spine</strong> to a
          <strong>recommended spine band</strong> built from draw weight, arrow length,
          point weight, and finished arrow weight — similar in spirit to a modernized
          Easton-style chart.
        </p>

        <p>
          In the Performance card you’ll see a small line:
          <br>
          <strong>“Effective load ≈ ${eff.toFixed(1)} lb”</strong>
          <br>
          That <em>effective load</em> is the same thing as
          <strong>effective draw weight</strong> that this panel is describing.
        </p>

        <p><strong>1) Build an “effective draw weight”</strong></p>
        <p>
          The calculator starts from your real draw weight and adds tuned bumps for:
        </p>
        <ul style="margin-left:1.25rem;">
          <li>Longer arrows (more leverage on the shaft)</li>
          <li>Heavier points (more load out front)</li>
          <li>Overall finished arrow weight</li>
        </ul>
        <p>
          Your inputs for this build are:
        </p>
        <ul style="margin-left:1.25rem;">
          <li>Draw weight ≈ <strong>${DW.toFixed(1)} lb</strong></li>
          <li>Arrow length ≈ <strong>${L.toFixed(2)} in</strong></li>
          <li>Point weight ≈ <strong>${PT.toFixed(0)} gr</strong></li>
          ${Number.isFinite(W) ? `<li>Total arrow weight ≈ <strong>${W.toFixed(1)} gr</strong></li>` : ''}
        </ul>
        <p>
          Those are combined into a single load number the shaft “feels”:
          <br>
          <strong>effective draw weight ≈ ${eff.toFixed(1)} lb</strong>.
        </p>

        <p><strong>2) Map effective draw weight → spine band</strong></p>
        <p>
          That effective load is then mapped to a static spine <em>band</em> —
          lighter loads want weaker shafts (higher spine numbers), heavier loads want
          stiffer shafts (lower spine numbers).
        </p>
        <ul style="margin-left:1.25rem;">
          <li>Recommended spine band ≈ <strong>${bandMin.toFixed(0)}–${bandMax.toFixed(0)}</strong></li>
          <li>Band center used for comparison ≈ <strong>${ctr.toFixed(0)}</strong></li>
        </ul>

        <p><strong>3) Compare your spine to the chart recommendation</strong></p>
        <ul style="margin-left:1.25rem;">
          <li>Your actual spine = <strong>${shaft.toFixed(0)}</strong></li>
          <li>Recommended center spine = <strong>${ctr.toFixed(0)}</strong></li>
          <li>
            Difference = your spine − recommended center =
            <strong>${shaft.toFixed(0)} − ${ctr.toFixed(0)} = ${delta.toFixed(0)}</strong>
          </li>
        </ul>

        <p>
          In plain words: your arrow is ${sideSummary}
        </p>

        <p style="margin-top:0.5rem;">
          Slightly stiff or slightly weak can both be tunable with good form and
          sensible FOC. This doesn’t replace paper tuning or broadhead flight testing,
          but it gives you a fast
          <strong>“does this shaft live in the right neighborhood?”</strong> sanity check.
        </p>
      `;
    }

  } else if (key === 'flatnessScore') {
    const fps = getNumeric('actualFPS');
    if (!Number.isFinite(fps) || fps <= 0) {
      html = `
        <h2>Flatness Score Math</h2>
        <p>
          Enter a valid launch FPS so the app can estimate the trajectory arc
          between 20 and 60 yards.
        </p>
      `;
    } else {
      const baseDrop20 = computeDropInches(20, fps);
      const drop60 = computeDropInches(60, fps);
      let peakFt = NaN;
      let label = '–';

      if (Number.isFinite(baseDrop20) && Number.isFinite(drop60)) {
        const extraDrop = drop60 - baseDrop20;
        peakFt = Math.max(0, extraDrop / 12);

        if (peakFt < 3.0)      label = 'Very Flat';
        else if (peakFt < 4.5) label = 'Flat';
        else                   label = 'Curved';
      }

      html = `
        <h2>Flatness Score Math</h2>
        <p>
          We model gravity drop at <strong>20 yd</strong> and <strong>60 yd</strong>,
          then look at how much additional drop happens between those points.
        </p>
        <p>
          That extra drop is converted into an effective arc height by 60 yd.
        </p>
        <p>
          Approximate effective height by 60 yd:
          <strong>${Number.isFinite(peakFt) ? peakFt.toFixed(2) : '–'} ft</strong>
        </p>
        <p>Score label: <strong>${label}</strong></p>
        <ul style="margin-left:1.25rem;">
          <li><strong>Very Flat</strong> → effective arc &lt; ~3 ft</li>
          <li><strong>Flat</strong> → ~3–4.5 ft</li>
          <li><strong>Curved</strong> → &gt; ~4.5 ft</li>
        </ul>
        <p>
          Use this to compare builds — it isn’t meant to be exact sight tape data,
          just a feel for how “flat” the rig is by 60 yards.
        </p>
      `;
    }
  }

  if (!html) {
    html = `
      <h2>Math</h2>
      <p>Math details are not available for this section yet.</p>
    `;
  }

  infoBody.innerHTML = html;
  infoOverlay.classList.add('open');
}

if (infoClose) {
  infoClose.addEventListener('click', () => infoOverlay.classList.remove('open'));
}

if (infoOverlay) {
  infoOverlay.addEventListener('click', (e) => {
    if (e.target === infoOverlay) infoOverlay.classList.remove('open');
  });
}

document.querySelectorAll('.info-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    e.preventDefault();
    const key = btn.dataset.info;
    if (key) openInfo(key);
  });
});

document.querySelectorAll('.math-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    e.preventDefault();
    const key = btn.dataset.math;
    if (key) openMath(key);
  });
});

/* ============================================================
   INITIALIZE
============================================================ */

refreshBuilds();
updateArrowWeightMode();
calculateEverything(true);
</script>
</body>
</html>